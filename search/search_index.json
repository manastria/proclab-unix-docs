{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"D\u00e9couverte pratique de la gestion des processus sous Linux","text":"<p>Cette activit\u00e9 p\u00e9dagogique vous permettra de d\u00e9couvrir et comprendre comment fonctionnent les processus sous Linux \u00e0 travers une approche exp\u00e9rimentale.</p>"},{"location":"#presentation","title":"Pr\u00e9sentation","text":"<p>La gestion des processus est un concept fondamental dans les syst\u00e8mes d'exploitation de type Unix. Au lieu d'aborder ce sujet de mani\u00e8re th\u00e9orique, nous vous proposons une approche pratique : vous allez manipuler, observer et exp\u00e9rimenter avec des processus r\u00e9els gr\u00e2ce au programme <code>proclab</code>.</p> <p>\u00c0 travers une s\u00e9rie d'exercices guid\u00e9s, vous d\u00e9couvrirez :</p> <ul> <li>Comment les processus interagissent avec le terminal</li> <li>La gestion des processus en avant-plan et arri\u00e8re-plan</li> <li>Les \u00e9tats particuliers comme les processus zombies et orphelins</li> <li>L'impact des priorit\u00e9s sur l'ex\u00e9cution des processus</li> </ul>"},{"location":"#organisation-de-lactivite","title":"Organisation de l'activit\u00e9","text":"<p>L'activit\u00e9 est structur\u00e9e en plusieurs sc\u00e9narios progressifs. Chaque sc\u00e9nario vous permet d'explorer un aspect particulier des processus Unix. Vous commencerez par des manipulations simples avant d'aborder des concepts plus avanc\u00e9s.</p>"},{"location":"#prerequis","title":"Pr\u00e9requis","text":"<p>Pour suivre cette activit\u00e9, vous devez :</p> <ul> <li>Disposer d'un syst\u00e8me Linux (Lubuntu recommand\u00e9)</li> <li>\u00catre \u00e0 l'aise avec l'utilisation basique du terminal</li> <li>Conna\u00eetre les commandes \u00e9l\u00e9mentaires Linux</li> </ul> <p>Nous vous recommandons d'utiliser le terminal Terminator qui permet d'avoir plusieurs terminaux dans la m\u00eame fen\u00eatre, ce qui sera tr\u00e8s utile pour certains exercices.</p>"},{"location":"#comment-debuter","title":"Comment d\u00e9buter ?","text":"<ol> <li>Commencez par lire la section Installation pour mettre en place votre environnement</li> <li>Suivez ensuite les sc\u00e9narios dans l'ordre propos\u00e9 dans la section Activit\u00e9s</li> <li>Consultez les Ressources pour approfondir vos connaissances</li> </ol> <p>N'h\u00e9sitez pas \u00e0 exp\u00e9rimenter au-del\u00e0 des sc\u00e9narios propos\u00e9s. L'objectif est de comprendre par la pratique comment fonctionnent les processus sous Linux.</p> <p>Conseil</p> <p>Gardez un terminal ouvert avec la commande <code>ps</code> pour observer l'\u00e9tat de vos processus tout au long des exercices. Cela vous aidera \u00e0 mieux comprendre ce qui se passe \u00e0 chaque \u00e9tape.</p>"},{"location":"about/","title":"About","text":"<p>Site officiel de mkdocs : https://www.mkdocs.org/</p> <p>Site officiel de mkdocs-material : https://squidfunk.github.io/mkdocs-material/</p> <p>Site web : https://manastria.github.io/proclab-unix-docs/</p>"},{"location":"installation/","title":"Installation de proclab \ud83d\ude80","text":"<p>Pour r\u00e9aliser ces activit\u00e9s p\u00e9dagogiques, vous aurez besoin d'installer deux \u00e9l\u00e9ments essentiels :</p> <ol> <li>Terminator - Un terminal avanc\u00e9 permettant d'avoir plusieurs vues</li> <li>Les outils proclab - Notre suite d'outils d'exp\u00e9rimentation</li> </ol>"},{"location":"installation/#1-terminator","title":"1. Terminator \ud83d\udda5\ufe0f","text":"<p>D\u00e9j\u00e0 install\u00e9 ?</p> <p>Terminator est tr\u00e8s probablement d\u00e9j\u00e0 install\u00e9 sur votre syst\u00e8me. Passez directement \u00e0 la section suivante si c'est le cas !</p> <p>Si Terminator n'est pas install\u00e9, ouvrez un terminal et ex\u00e9cutez :</p> <pre><code>sudo apt install terminator\n</code></pre> <p>Une fois install\u00e9, vous pouvez lancer Terminator de deux fa\u00e7ons :</p> <ul> <li>Via le menu des applications</li> <li>En tapant <code>terminator</code> dans un terminal</li> </ul> <p>Les raccourcis indispensables de Terminator</p> Action Raccourci Diviser verticalement Ctrl+Shift+E Diviser horizontalement Ctrl+Shift+O Fermer le terminal actif Ctrl+Shift+W Naviguer entre les vues Ctrl+Tab"},{"location":"installation/#2-installation-des-outils-proclab","title":"2. Installation des outils proclab \ud83d\udee0\ufe0f","text":"<p>Pourquoi une archive pr\u00e9compil\u00e9e ?</p> <p>Nous fournissons une version pr\u00e9-compil\u00e9e de la suite proclab pour garantir une installation rapide et une exp\u00e9rience identique pour tous les \u00e9tudiants.</p>"},{"location":"installation/#etape-1-preparation-du-repertoire","title":"\u00c9tape 1 : Pr\u00e9paration du r\u00e9pertoire","text":"<p>Configuration probablement d\u00e9j\u00e0 effectu\u00e9e</p> <p>Sur votre syst\u00e8me, le r\u00e9pertoire <code>~/bin</code> est tr\u00e8s certainement d\u00e9j\u00e0 cr\u00e9\u00e9 et configur\u00e9. Vous pouvez le v\u00e9rifier rapidement avec : <pre><code>echo $PATH | grep ~/bin\n</code></pre> Si vous voyez <code>~/bin</code> dans le r\u00e9sultat, tout est d\u00e9j\u00e0 configur\u00e9 ! Passez directement \u00e0 l'\u00e9tape 2.</p> <p>Si le r\u00e9pertoire n'est pas configur\u00e9 (cas rare), voici la proc\u00e9dure :</p> <ol> <li>Cr\u00e9ez le r\u00e9pertoire <code>bin</code> :</li> </ol> <pre><code>mkdir -p ~/bin\n</code></pre> <ol> <li>Ajoutez ces lignes \u00e0 votre <code>~/.bashrc</code> :</li> </ol> <pre><code># Ajout du r\u00e9pertoire ~/bin au PATH\nif [ -d \"$HOME/bin\" ] ; then\n    PATH=\"$HOME/bin:$PATH\"\nfi\n</code></pre> <ol> <li>Appliquez les changements :</li> </ol> <pre><code>source ~/.bashrc\n</code></pre>"},{"location":"installation/#etape-2-telechargement-et-installation","title":"\u00c9tape 2 : T\u00e9l\u00e9chargement et installation","text":"<ol> <li>\u27a1\ufe0f Acc\u00e9dez \u00e0 la page de la derni\u00e8re version</li> <li>Cliquez sur \"Assets\" pour d\u00e9rouler la liste des fichiers t\u00e9l\u00e9chargeables</li> <li>Choisissez le fichier <code>proclab-X.Y.Z.tar.gz</code> (o\u00f9 X.Y.Z est le num\u00e9ro de version)</li> </ol> <p>Qu'est-ce que les 'Assets' ?</p> <p>Dans le contexte du d\u00e9veloppement logiciel et de GitHub, les \"Assets\" sont les fichiers joints \u00e0 une version (release) d'un logiciel. Il peut s'agir des ex\u00e9cutables, des archives, de la documentation ou d'autres ressources n\u00e9cessaires. C'est un terme technique couramment utilis\u00e9 pour d\u00e9signer les ressources ou \u00e9l\u00e9ments associ\u00e9s \u00e0 un projet.</p> <ol> <li>D\u00e9compressez l'archive dans votre r\u00e9pertoire <code>~/bin</code> :</li> </ol> <pre><code>cd ~/bin\ntar xzf ~/T\u00e9l\u00e9chargements/proclab-*.tar.gz\n</code></pre>"},{"location":"installation/#etape-3-verification","title":"\u00c9tape 3 : V\u00e9rification","text":"<p>Testez chaque outil pour v\u00e9rifier l'installation :</p> <pre><code>procarbo --version     # Outil pour l'arborescence des processus\nproclab --version     # Programme principal\nprocorhpan --version  # Outil pour les processus orphelins\nprocsignal --version  # Outil pour la gestion des signaux\nprocstate --version   # Outil pour l'\u00e9tat des processus\nproczombi --version   # Outil pour les processus zombies\n</code></pre>"},{"location":"installation/#test-complet","title":"Test complet \u2705","text":"<p>R\u00e9alisons un test rapide pour confirmer que tout fonctionne :</p> <ol> <li> <p>Pr\u00e9paration :</p> <ul> <li>Lancez Terminator</li> <li>Divisez la fen\u00eatre en deux avec Ctrl+Shift+E</li> </ul> </li> <li> <p>Test :     Dans le terminal gauche, testez chaque outil :</p> <pre><code># Test de chaque outil\nprocarbo         # Ctrl+C pour arr\u00eater\nproclab          # Ctrl+C pour arr\u00eater\nprocorhpan       # Choisir 'Quitter' dans le menu\nprocsignal       # Ctrl+C pour arr\u00eater\nprocstate        # Ctrl+C pour arr\u00eater\nproczombi        # Choisir 'Quitter' dans le menu\n</code></pre> </li> </ol> <p>R\u00e9solution des probl\u00e8mes courants</p> Permission deniedCommand not found <ol> <li>V\u00e9rifiez les permissions des fichiers :    <pre><code>chmod +x ~/bin/proc*\n</code></pre></li> <li>Contr\u00f4lez que tous les fichiers sont bien extraits</li> </ol> <ol> <li>V\u00e9rifiez que <code>~/bin</code> est dans votre PATH :    <pre><code>echo $PATH | grep ~/bin\n</code></pre></li> <li>Si non, relancez votre terminal apr\u00e8s avoir modifi\u00e9 <code>.bashrc</code></li> </ol>"},{"location":"installation/#pour-aller-plus-loin","title":"Pour aller plus loin \ud83d\udd0d","text":"<p>Le code source de la suite proclab est disponible sur GitHub. Si vous souhaitez explorer son fonctionnement interne ou la compiler vous-m\u00eame :</p> <p>\u27a1\ufe0f Code source sur GitHub</p> <p>Pr\u00e9requis pour la compilation</p> <ul> <li>Espace disque : ~1.5 GB</li> <li>D\u00e9pendances : gcc, make et autres outils de compilation</li> <li>Temps : 5-10 minutes selon votre syst\u00e8me</li> </ul> <p>Les instructions d\u00e9taill\u00e9es sont disponibles dans le fichier <code>README.md</code> du d\u00e9p\u00f4t.</p>"},{"location":"installation/#pret-a-commencer","title":"Pr\u00eat \u00e0 commencer ? \ud83c\udfaf","text":"<p>Une fois la suite proclab install\u00e9e, vous pouvez d\u00e9buter les activit\u00e9s. Direction le premier sc\u00e9nario qui vous familiarisera avec les concepts de base !</p>"},{"location":"activites/","title":"Introduction aux activit\u00e9s pratiques","text":"<p>Les processus constituent un concept fondamental des syst\u00e8mes Unix. Pour comprendre r\u00e9ellement leur fonctionnement, rien ne vaut la pratique ! Cette s\u00e9rie d'activit\u00e9s vous guidera dans l'exploration progressive des processus, en commen\u00e7ant par les bases pour aller jusqu'aux concepts plus avanc\u00e9s.</p>"},{"location":"activites/#vue-densemble","title":"Vue d'ensemble","text":"<p>Au fil des activit\u00e9s, vous d\u00e9couvrirez diff\u00e9rents aspects de la gestion des processus sous Unix. Chaque sc\u00e9nario est con\u00e7u pour vous faire explorer un concept sp\u00e9cifique de mani\u00e8re pratique et interactive.</p> <pre><code>graph LR\n    A[Terminal] --&gt; B[Foreground&lt;br/&gt;Background]\n    B --&gt; C[Zombies]\n    C --&gt; D[Orphelins]\n    D --&gt; E[Priorit\u00e9s]\n    style A fill:#e3f2fd,stroke:#333\n    style B fill:#e8f5e9,stroke:#333\n    style C fill:#fff3e0,stroke:#333\n    style D fill:#fce4ec,stroke:#333\n    style E fill:#f3e5f5,stroke:#333</code></pre>"},{"location":"activites/#les-scenarios","title":"Les sc\u00e9narios","text":""},{"location":"activites/#scenario-1-terminal-et-processus","title":"Sc\u00e9nario 1 : Terminal et processus","text":"<p>D\u00e9couvrez comment les processus interagissent avec leur terminal. Vous apprendrez \u00e0 :</p> <ul> <li>Identifier les terminaux et leurs processus</li> <li>Comprendre la relation entre un processus et son terminal</li> <li>Observer les processus avec diff\u00e9rentes commandes</li> </ul>"},{"location":"activites/#scenario-2-gestion-foregroundbackground","title":"Sc\u00e9nario 2 : Gestion foreground/background","text":"<p>Explorez comment g\u00e9rer plusieurs processus dans un m\u00eame terminal :</p> <ul> <li>Mettre un processus en pause avec Ctrl+Z</li> <li>Basculer entre avant-plan et arri\u00e8re-plan</li> <li>Manipuler plusieurs processus simultan\u00e9ment</li> </ul>"},{"location":"activites/#scenario-3-les-processus-zombies","title":"Sc\u00e9nario 3 : Les processus zombies","text":"<p>Plongez dans le monde myst\u00e9rieux des processus zombies :</p> <ul> <li>Comprendre ce qu'est un processus zombie</li> <li>Observer comment ils se cr\u00e9ent</li> <li>Apprendre \u00e0 les g\u00e9rer proprement</li> </ul>"},{"location":"activites/#scenario-4-les-processus-orphelins","title":"Sc\u00e9nario 4 : Les processus orphelins","text":"<p>D\u00e9couvrez ce qui arrive quand un processus perd son parent :</p> <ul> <li>Comprendre le concept de processus orphelin</li> <li>Observer le r\u00f4le de init/systemd</li> <li>Suivre la r\u00e9affectation des processus</li> </ul>"},{"location":"activites/#scenario-5-les-priorites","title":"Sc\u00e9nario 5 : Les priorit\u00e9s","text":"<p>Explorez la gestion des priorit\u00e9s des processus :</p> <ul> <li>Comprendre le syst\u00e8me de priorit\u00e9s</li> <li>Modifier la priorit\u00e9 des processus</li> <li>Observer l'impact sur leur ex\u00e9cution</li> </ul>"},{"location":"activites/#comment-utiliser-ces-activites","title":"Comment utiliser ces activit\u00e9s","text":""},{"location":"activites/#progression-recommandee","title":"Progression recommand\u00e9e","text":"<p>Les sc\u00e9narios sont con\u00e7us pour \u00eatre suivis dans l'ordre. Chaque activit\u00e9 s'appuie sur les connaissances acquises dans les pr\u00e9c\u00e9dentes.</p> <p>Conseils pour bien progresser</p> <ul> <li>Prenez le temps de bien comprendre chaque concept avant de passer au suivant</li> <li>N'h\u00e9sitez pas \u00e0 exp\u00e9rimenter au-del\u00e0 des instructions donn\u00e9es</li> <li>Utilisez l'aide contextuelle de proclab (SIGUSR1/SIGUSR2) si vous \u00eates bloqu\u00e9</li> </ul>"},{"location":"activites/#ressources-disponibles","title":"Ressources disponibles","text":"<p>Pour chaque activit\u00e9, vous disposez de :</p> <ul> <li>Instructions d\u00e9taill\u00e9es pas \u00e0 pas</li> <li>Explications des concepts cl\u00e9s</li> <li>Commandes de r\u00e9f\u00e9rence</li> <li>Visualisations et diagrammes</li> </ul>"},{"location":"activites/#support-theorique","title":"Support th\u00e9orique","text":"<p>En parall\u00e8le des activit\u00e9s pratiques, vous pouvez consulter :</p> <ul> <li>L'analogie du restaurant pour une vision intuitive</li> <li>La documentation sur les processus pour les d\u00e9tails techniques</li> <li>Les informations sur les signaux pour comprendre les communications</li> </ul>"},{"location":"activites/#pret-a-commencer","title":"Pr\u00eat \u00e0 commencer ?","text":"<p>D\u00e9marrez avec le premier sc\u00e9nario \u2192</p>"},{"location":"activites/arbo/","title":"Sc\u00e9nario : Arborescence des processus","text":""},{"location":"activites/arbo/#objectifs-dapprentissage","title":"Objectifs d'apprentissage","text":"<p>\u00c0 la fin de ce sc\u00e9nario, vous serez capable de :</p> <ul> <li>Comprendre ce qu'est une arborescence de processus</li> <li>Visualiser les relations parent-enfant entre les processus</li> <li>Utiliser les commandes <code>ps</code>, <code>pstree</code> et <code>htop</code> pour observer l'arborescence</li> <li>Identifier le parent d'un processus donn\u00e9</li> </ul>"},{"location":"activites/arbo/#concepts-fondamentaux","title":"Concepts fondamentaux","text":""},{"location":"activites/arbo/#les-identifiants-de-processus","title":"Les identifiants de processus","text":"<p>Sous Linux, chaque processus est identifi\u00e9 par deux num\u00e9ros importants :</p> <ul> <li>Le PID (Process ID) est un identifiant unique pour chaque processus.</li> </ul> <pre><code># Exemple : chaque processus a un PID diff\u00e9rent\nPID 1234 : firefox\nPID 1235 : terminal\nPID 1236 : bash\n</code></pre> <ul> <li>Le PPID (Parent Process ID) identifie le parent du processus.</li> </ul> <pre><code># Exemple : le PPID indique quel processus est le parent\nPID 1236 (bash) \u2192 PPID 1235 (terminal)\n</code></pre> <p>Pour bien comprendre</p> <ul> <li>Le PID, c'est comme votre num\u00e9ro d'\u00e9tudiant : il est unique et vous identifie.</li> <li>Le PPID, c'est comme le num\u00e9ro de votre classe : il indique \u00e0 quel groupe vous appartenez.</li> </ul>"},{"location":"activites/arbo/#quest-ce-quune-arborescence-de-processus","title":"Qu'est-ce qu'une arborescence de processus ?","text":"<p>Une arborescence de processus (process tree) est la repr\u00e9sentation des relations entre les processus sous Linux, o\u00f9 chaque processus est cr\u00e9\u00e9 par un autre processus (son parent).</p> <p>L'analogie de l'entreprise</p> <p>Imaginez une entreprise avec son organigramme :</p> <ul> <li>Le PDG (comme le processus <code>init</code> ou <code>systemd</code>) est au sommet</li> <li>Les managers (processus parents) supervisent leurs \u00e9quipes</li> <li>Les employ\u00e9s (processus enfants) travaillent sous la direction des managers</li> <li>Chaque employ\u00e9 sait qui est son responsable (comme le PPID - Parent Process ID)</li> </ul> <p>Question de r\u00e9flexion : En quoi cette hi\u00e9rarchie aide-t-elle \u00e0 organiser le travail ?</p> <p>Indices pour la r\u00e9flexion : - Que se passe-t-il quand un employ\u00e9 a un probl\u00e8me ? \u00c0 qui s'adresse-t-il ? - Comment le PDG sait-il ce qui se passe dans l'entreprise ? - Pourquoi est-il important de savoir qui est responsable de qui ?</p>"},{"location":"activites/arbo/#les-concepts-cles","title":"Les concepts cl\u00e9s","text":"<ol> <li> <p>Le processus init/systemd (PID 1)</p> <ul> <li>C'est l'anc\u00eatre de tous les processus</li> <li>Il d\u00e9marre automatiquement au d\u00e9marrage du syst\u00e8me</li> <li>Il adopte les processus orphelins</li> </ul> </li> <li> <p>La relation parent-enfant</p> <ul> <li>Chaque processus (sauf <code>init</code>) a un parent</li> <li>Un processus peut cr\u00e9er plusieurs enfants</li> <li>On parle de \"fork\" quand un processus cr\u00e9e un enfant</li> </ul> </li> </ol> <p>Questions pr\u00e9liminaires</p> <p>Avant de commencer les manipulations, r\u00e9fl\u00e9chissons :</p> <ol> <li> <p>Pourquoi est-il important de conna\u00eetre les relations entre les processus ?</p> <p>Pour vous aider :</p> <ul> <li>Dans une famille, pourquoi est-il important de savoir qui sont les parents de chaque enfant ?</li> <li>Si un parent ne rentre pas \u00e0 la maison, qui doit s'occuper des enfants ?</li> <li>Quand un processus a un probl\u00e8me, pourquoi est-il utile de savoir qui l'a cr\u00e9\u00e9 ?</li> </ul> <p>Exemple concret :</p> <p>Quand une application plante, le syst\u00e8me doit :</p> <ul> <li>Informer le processus parent du probl\u00e8me</li> <li>Permettre au parent de g\u00e9rer la situation</li> <li>S'assurer qu'aucune ressource n'est perdue</li> </ul> </li> <li> <p>Que se passe-t-il quand un processus parent se termine ?</p> <p>Indices :</p> <ul> <li>Que devient une \u00e9quipe quand son manager quitte l'entreprise ?</li> <li>Qui doit s'occuper des \"employ\u00e9s\" restants ?</li> </ul> </li> </ol>"},{"location":"activites/arbo/#mise-en-pratique","title":"Mise en pratique","text":""},{"location":"activites/arbo/#preparation","title":"Pr\u00e9paration","text":"<ol> <li>Ouvrez deux terminaux c\u00f4te \u00e0 c\u00f4te dans Terminator (Ctrl+Shift+E)</li> <li>Terminal gauche : pour lancer les programmes</li> <li>Terminal droit : pour observer l'arborescence</li> </ol>"},{"location":"activites/arbo/#etape-1-observer-une-arborescence-simple","title":"\u00c9tape 1 : Observer une arborescence simple","text":"<ol> <li> <p>Dans le terminal gauche, lancez :     <pre><code>procarbo --depth 2 --width 2\n</code></pre></p> <p>Les options permettent de limiter la profondeur et la largeur de l'arborescence.</p> </li> <li> <p>Dans le terminal droit, observez avec :     <pre><code>ps --forest\n</code></pre></p> </li> </ol> <p>Exercice d'observation</p> <ol> <li> <p>Observez la sortie de <code>ps --forest</code>. Que repr\u00e9sentent les caract\u00e8res <code>\u2500\u252c\u2500</code> et <code>\u2514\u2500</code> ?</p> <p>Aide visuelle : <pre><code>parent1\u2500\u252c\u2500enfant1\n        \u251c\u2500enfant2\n        \u2514\u2500enfant3\n\nparent2\u2500\u2500\u2500enfant_unique\n</code></pre></p> <p>Comment lire cette repr\u00e9sentation :</p> <ul> <li>Le caract\u00e8re <code>\u252c</code> indique que le processus parent a plusieurs enfants</li> <li>Le caract\u00e8re <code>\u251c</code> montre qu'il y a d'autres enfants qui suivent</li> <li>Le caract\u00e8re <code>\u2514</code> indique le dernier enfant de ce parent</li> <li>Les lignes <code>\u2500</code> relient un parent \u00e0 ses enfants</li> </ul> <p>Exemple concret :</p> <pre><code>firefox\u2500\u252c\u2500firefox (onglet 1)\n        \u251c\u2500firefox (onglet 2)\n        \u2514\u2500firefox (onglet 3)\n</code></pre> <p>Ici, le processus Firefox principal a cr\u00e9\u00e9 trois processus enfants, un pour chaque onglet.</p> </li> <li> <p>Combien de niveaux de processus voyez-vous ?</p> <p>Pour compter les niveaux :</p> <ul> <li>Commencez par le processus parent</li> <li>Suivez les lignes vers la droite</li> <li>Chaque d\u00e9calage repr\u00e9sente un nouveau niveau</li> </ul> </li> </ol>"},{"location":"activites/arbo/#etape-2-explorer-avec-pstree","title":"\u00c9tape 2 : Explorer avec pstree","text":"<p>La commande <code>pstree</code> (Process Tree) affiche les processus sous forme d'arbre. L'option <code>-p</code> ajoute les PIDs entre parenth\u00e8ses.</p> <p>Lancez la commande : <pre><code>pstree -p\n</code></pre></p> <p>Exemple de sortie : <pre><code>systemd(1)\u2500\u252c\u2500ModemManager(889)\u2500\u252c\u2500{ModemManager}(904)\n           \u2502                   \u2514\u2500{ModemManager}(906)\n           \u251c\u2500agetty(890)\n           \u251c\u2500sshd(891)\u2500\u2500\u2500sshd(23617)\u2500\u2500\u2500bash(23619)\u2500\u2500\u2500pstree(23620)\n           \u2514\u2500terminator(12567)\u2500\u252c\u2500bash(12575)\u2500\u2500\u2500procarbo(12898)\n                               \u2514\u2500bash(12576)\n</code></pre></p> <p>Comment lire cette sortie :</p> <ol> <li>L'arbre commence toujours par <code>systemd(1)</code> qui est le processus initial</li> <li>Le chiffre 1 est son PID</li> <li> <p>Tout part de ce processus racine</p> </li> <li> <p>Les traits repr\u00e9sentent les relations :</p> </li> <li><code>\u252c</code> signifie \"a plusieurs enfants\"</li> <li><code>\u251c</code> signifie \"un enfant, et il y en a d'autres\"</li> <li><code>\u2514</code> signifie \"dernier enfant\"</li> <li> <p><code>\u2500</code> connecte un parent \u00e0 son enfant</p> </li> <li> <p>Dans cet exemple :</p> </li> <li><code>ModemManager(889)</code> g\u00e8re le modem avec deux processus l\u00e9gers (threads)</li> <li><code>sshd(891)</code> g\u00e8re les connexions SSH</li> <li><code>terminator(12567)</code> est notre terminal avec deux shells bash</li> </ol> <p>Processus l\u00e9gers (threads)</p> <p>Les accolades comme dans <code>{ModemManager}</code> indiquent des processus l\u00e9gers (threads). Ce sont des sous-processus qui partagent les ressources de leur parent.</p> <p>Astuce</p> <p>Vous pouvez filtrer l'affichage en ajoutant le PID d'un processus sp\u00e9cifique : <pre><code>pstree -p &lt;PID&gt;\n</code></pre> Cela montre uniquement l'arbre \u00e0 partir de ce processus.</p> <p>Analyse de l'arborescence</p> <ol> <li> <p>Que signifient les nombres entre parenth\u00e8ses ?</p> <p>Indice : Comparez avec les PID affich\u00e9s par <code>ps</code></p> </li> <li> <p>Pourquoi certains processus apparaissent-ils plusieurs fois ?</p> <p>Pour comprendre : - Pensez \u00e0 un employ\u00e9 qui travaille dans plusieurs \u00e9quipes - Est-ce le m\u00eame processus ou des processus diff\u00e9rents ?</p> </li> </ol> <ol> <li> <p>Lister les processus actifs     Dans le terminal droit, utilisez la commande suivante pour afficher les processus en cours :</p> <pre><code>psess\n</code></pre> <p>Explications : - <code>psess</code> est un alias qui affiche les colonnes essentielles pour analyser les processus :     - <code>PPID</code> : PID du processus parent.     - <code>PID</code> : Identifiant du processus.     - <code>STAT</code> : \u00c9tat du processus (Running, Sleeping, etc.).     - <code>TTY</code> : Terminal associ\u00e9 au processus.     - <code>USER</code> : Utilisateur propri\u00e9taire.     - <code>CMD</code> : Commande utilis\u00e9e pour d\u00e9marrer le processus.</p> <p>Question : Quels sont les PID et PPID des processus cr\u00e9\u00e9s par le programme <code>procarbo</code> ?</p> </li> </ol>"},{"location":"activites/arbo/#etape-3-analyser-les-processus-lies-a-terminator","title":"\u00c9tape 3 : Analyser les processus li\u00e9s \u00e0 Terminator","text":"<ol> <li> <p>Observer les processus enfants de Terminator     Utilisez l\u2019alias <code>termtree</code> pour afficher les processus enfants de Terminator :</p> <pre><code>termtree\n</code></pre> <p>Question : Quels processus sont cr\u00e9\u00e9s sp\u00e9cifiquement par Terminator ?</p> </li> </ol>"},{"location":"activites/arbo/#etape-4-explorer-larborescence-avec-htop","title":"\u00c9tape 4 : Explorer l\u2019arborescence avec <code>htop</code>","text":"<ol> <li> <p>Lancer <code>htop</code>     Dans le terminal droit, ex\u00e9cutez :</p> <pre><code>htop\n</code></pre> <p>Explications : - <code>htop</code> : Outil interactif pour surveiller les processus. - Utilisez la touche F5 pour afficher les processus en mode arborescence. - Naviguez avec les fl\u00e8ches pour explorer les relations parent-enfant.</p> <p>Question : Quel est le PID de <code>procarbo</code> et comment ses enfants sont-ils affich\u00e9s dans <code>htop</code> ?</p> </li> </ol>"},{"location":"activites/arbo/#3-exercices-pratiques","title":"3. Exercices pratiques","text":""},{"location":"activites/arbo/#exercice-1-analyser-les-relations-parent-enfant","title":"Exercice 1 : Analyser les relations parent-enfant","text":"<ol> <li>Relancez <code>procarbo</code>.</li> <li>Utilisez <code>psess</code>, <code>treeproc</code> et <code>ps --forest</code> pour analyser l\u2019arborescence des processus.</li> </ol> <p>Question : Comment l\u2019arborescence \u00e9volue lorsque vous terminez un processus enfant avec <code>kill</code> ?</p>"},{"location":"activites/arbo/#exercice-2-comprendre-les-etats-des-processus","title":"Exercice 2 : Comprendre les \u00e9tats des processus","text":"<ol> <li>Observez la colonne <code>STAT</code> dans la commande <code>psess</code>.</li> <li>Identifiez les diff\u00e9rents \u00e9tats (<code>S</code>, <code>R</code>, <code>Z</code>, etc.).</li> </ol> <p>Question : Que signifie chaque \u00e9tat ? Comment v\u00e9rifier si un processus est en veille ou actif ?</p>"},{"location":"activites/arbo/#exercice-3-experimenter-avec-plusieurs-instances","title":"Exercice 3 : Exp\u00e9rimenter avec plusieurs instances","text":"<ol> <li>Lancez plusieurs instances de <code>procarbo</code>.</li> <li>Utilisez <code>treeproc</code> et <code>psess</code> pour analyser les relations entre les processus.</li> </ol> <p>Question : Comment distinguer les diff\u00e9rentes instances et leurs enfants dans l\u2019arborescence ?</p>"},{"location":"activites/arbo/#4-tableau-recapitulatif-des-commandes","title":"4. Tableau r\u00e9capitulatif des commandes","text":"Commande Alias Explication Cas d\u2019utilisation <code>ps -o ...</code> <code>psess</code> Affiche les colonnes essentielles des processus. Observer les PID, PPID, \u00e9tat et commande des processus actifs. <code>ps --forest</code> (aucun) Affiche les processus sous forme d\u2019arborescence. Visualiser les relations parent-enfant. <code>pstree</code> <code>treeproc</code> Affiche l\u2019arborescence compl\u00e8te avec les PID. Explorer toutes les relations de processus. <code>pstree $$</code> <code>stree</code> Affiche l\u2019arborescence autour du shell courant. Analyser les processus directement li\u00e9s au terminal. <code>pstree ...</code> <code>termtree</code> Affiche les enfants de Terminator. Visualiser les processus cr\u00e9\u00e9s par Terminator. <code>htop</code> (aucun) Affiche un moniteur interactif des processus en arborescence. Explorer et surveiller les processus en temps r\u00e9el."},{"location":"activites/arbo/#points-cles-a-retenir","title":"Points cl\u00e9s \u00e0 retenir","text":"<ul> <li>Tout processus (sauf init/systemd) a un parent</li> <li>L'arborescence permet de visualiser les relations entre processus</li> <li>Les processus sont organis\u00e9s en arborescence, chaque processus ayant un parent (<code>PPID</code>) et pouvant avoir des enfants (<code>PID</code>).</li> <li>Des outils comme <code>ps --forest</code>, <code>pstree</code> et <code>htop</code> permettent de visualiser et d\u2019analyser cette hi\u00e9rarchie.</li> <li>Les alias simplifient l\u2019utilisation des commandes complexes pour des t\u00e2ches fr\u00e9quentes.</li> <li>Le PID 1 (init/systemd) est la racine de l'arbre</li> </ul>"},{"location":"activites/arbo/#evaluation-des-connaissances","title":"\u00c9valuation des connaissances","text":""},{"location":"activites/arbo/#questions-a-choix-multiples","title":"Questions \u00e0 choix multiples","text":"<p>Q1 : Quelle commande affiche une arborescence des processus avec leurs PID ?</p> <ol> <li><code>psess</code></li> <li><code>pstree</code></li> <li><code>ps --forest</code></li> </ol> <p>R\u00e9ponse attendue : 2.</p> <p>Q2 : Quel alias permet d\u2019afficher uniquement les processus enfants de Terminator ?</p> <ol> <li><code>treeproc</code></li> <li><code>stree</code></li> <li><code>termtree</code></li> </ol> <p>R\u00e9ponse attendue : 3.</p> <p>Q3 : Que signifie l\u2019\u00e9tat <code>S</code> dans la colonne <code>STAT</code> des processus ?</p> <ol> <li>Processus actif.</li> <li>Processus en veille.</li> <li>Processus zombie.</li> </ol> <p>R\u00e9ponse attendue : 2.</p> <p>Q3. Qu'est-ce qu'un processus parent ?     - [ ] Un processus tr\u00e8s ancien     - [ ] Un processus qui en cr\u00e9e d'autres     - [ ] Le premier processus du syst\u00e8me</p> <pre><code>**Indice :** Pensez \u00e0 la relation manager-employ\u00e9\n</code></pre> <p>Q4. Quel est le r\u00f4le de init (PID 1) ?</p> <pre><code>**Pour r\u00e9fl\u00e9chir :**\n- Que se passe-t-il au d\u00e9marrage du syst\u00e8me ?\n- Qui s'occupe des processus orphelins ?\n</code></pre>"},{"location":"activites/arbo/#lien-avec-les-notions-futures","title":"Lien avec les notions futures","text":"<p>Dans les prochains sc\u00e9narios, nous verrons : - Les processus zombies et orphelins - La communication entre processus - La gestion des signaux entre processus</p> <p>Pr\u00e9paration pour la suite</p> <p>R\u00e9fl\u00e9chissez \u00e0 : - Que se passe-t-il quand un processus parent meurt avant ses enfants ? - Comment les processus peuvent-ils communiquer entre eux ?</p>"},{"location":"activites/etats/","title":"Sc\u00e9nario : \u00c9tats des processus","text":"<p>Imaginez que vous \u00eates un d\u00e9tective qui observe le comportement des processus sur votre syst\u00e8me. Dans ce sc\u00e9nario, nous allons d\u00e9couvrir comment les processus \u00ab\u00a0vivent\u00a0\u00bb dans Linux, quels \u00e9tats ils peuvent prendre, et comment nous pouvons les observer et les influencer.</p>"},{"location":"activites/etats/#objectifs-dapprentissage","title":"Objectifs d'apprentissage","text":"<p>\u00c0 la fin de ce sc\u00e9nario, vous serez capable de\u00a0:</p> <ul> <li>Comprendre ce qu\u2019est l\u2019\u00e9tat d\u2019un processus et pourquoi il change</li> <li>Utiliser des outils pour observer ces \u00e9tats</li> <li>Manipuler l\u2019\u00e9tat d\u2019un processus de mani\u00e8re basique</li> </ul>"},{"location":"activites/etats/#preparation-notre-laboratoire-dobservation","title":"Pr\u00e9paration\u00a0: Notre laboratoire d\u2019observation","text":"<p>Pour mener nos exp\u00e9riences, nous allons utiliser deux outils\u00a0:</p> <ol> <li> <p>Le programme procstate\u00a0: Un programme sp\u00e9cial qui va nous montrer de mani\u00e8re visible les diff\u00e9rents \u00e9tats d\u2019un processus. C\u2019est comme une petite souris de laboratoire qui va nous aider \u00e0 comprendre le comportement des processus.</p> </li> <li> <p>Terminator\u00a0: Notre \u00ab\u00a0laboratoire\u00a0\u00bb avec deux zones d\u2019observation\u00a0:</p> </li> <li>\u00c0 gauche\u00a0: pour ex\u00e9cuter notre programme</li> <li>\u00c0 droite\u00a0: pour l\u2019observer avec diff\u00e9rents outils</li> </ol>"},{"location":"activites/etats/#mise-en-place-du-laboratoire","title":"Mise en place du laboratoire","text":"<ol> <li>Ouvrez Terminator</li> <li>Appuyez sur Ctrl+Shift+E pour diviser la fen\u00eatre verticalement</li> <li>Vous avez maintenant deux terminaux c\u00f4te \u00e0 c\u00f4te</li> </ol>"},{"location":"activites/etats/#partie-1-premiers-pas-dans-lobservation-des-processus","title":"Partie 1\u00a0: Premiers pas dans l\u2019observation des processus","text":""},{"location":"activites/etats/#le-pid-la-carte-didentite-dun-processus","title":"Le PID\u00a0: La carte d\u2019identit\u00e9 d\u2019un processus","text":"<p>Avant de commencer nos observations, nous devons comprendre comment identifier un processus. Sous Linux, chaque processus re\u00e7oit un num\u00e9ro unique appel\u00e9 PID (Process IDentifier). C\u2019est comme un num\u00e9ro de s\u00e9curit\u00e9 sociale pour les processus \u2014 il est unique et permet de les identifier sans ambigu\u00eft\u00e9.</p> <p>Dans le terminal de gauche, lancez notre programme d\u2019observation\u00a0:</p> <pre><code>./procstate\n</code></pre> <p>Vous devriez voir quelque chose comme\u00a0:</p> <pre><code>[D\u00e9but] PID = 1234\nCe programme alterne 5 s de calcul intensif (BUSY) et 3 s de sommeil (SLEEP).\n</code></pre> <p>R\u00e9flexion initiale</p> <p>Commencez par observer le PID affich\u00e9 lorsque le programme est lanc\u00e9. Voici les \u00e9tapes \u00e0 suivre pour v\u00e9rifier si le PID change \u00e0 chaque ex\u00e9cution\u00a0:</p> <ol> <li>Notez le PID actuel affich\u00e9 \u00e0 l\u2019\u00e9cran.</li> <li>Arr\u00eatez le programme en utilisant la combinaison de touches Ctrl+C.</li> <li>Relancez le programme et comparez le PID affich\u00e9 avec celui not\u00e9 pr\u00e9c\u00e9demment.</li> </ol> <p>Question : Le PID est-il identique \u00e0 chaque lancement\u00a0?</p> <p>Ensuite, r\u00e9fl\u00e9chissez \u00e0 la question suivante\u00a0: pourquoi pensez-vous que chaque processus a besoin d\u2019un identifiant unique\u00a0?</p>"},{"location":"activites/etats/#a-la-recherche-du-pid-perdu","title":"\u00c0 la recherche du PID perdu","text":"<p>Si vous perdez le PID de vue ou si vous lancez plusieurs instances du programme, Linux fournit un outil tr\u00e8s pratique pour retrouver les PID\u00a0: la commande <code>pidof</code>. Elle fait exactement ce que son nom sugg\u00e8re \u2014 elle trouve le PID d\u2019un programme \u00e0 partir de son nom.</p> <p>Dans le terminal de droite, ex\u00e9cutez :</p> <pre><code>pidof procstate\n</code></pre> <p>Comment fonctionne pidof</p> <p>La commande <code>pidof</code> cherche dans la liste des processus en cours d\u2019ex\u00e9cution et affiche les PID des processus qui correspondent au nom donn\u00e9. C\u2019est comme demander\u00a0: \u00ab\u00a0Qui s\u2019appelle procstate parmi les processus en cours\u00a0?\u00a0\u00bb</p> <p>Si vous lancez plusieurs fois le m\u00eame programme, <code>pidof</code> affichera plusieurs PID, un pour chaque instance en cours d'ex\u00e9cution.</p>"},{"location":"activites/etats/#la-magie-de-la-substitution-de-commande","title":"La magie de la substitution de commande","text":"<p>Dans le shell Linux, nous pouvons utiliser le r\u00e9sultat d\u2019une commande directement dans une autre commande. C\u2019est ce qu\u2019on appelle la substitution de commande, et elle se fait avec la syntaxe <code>$(commande)</code>.</p> <p>Essayons de comprendre avec un exemple simple. Dans le terminal de droite, tapez\u00a0:</p> <pre><code>echo \"Bonjour, nous sommes le $(date)\"\n</code></pre> <p>Dans cette commande :</p> <ol> <li>Le shell ex\u00e9cute d\u2019abord la commande entre <code>$( )</code></li> <li>Il remplace ensuite toute l'expression $(date) par son r\u00e9sultat</li> <li>Finalement, il ex\u00e9cute la commande echo avec le texte substitu\u00e9</li> </ol> <p>C'est comme si vous disiez au shell : \"L\u00e0 o\u00f9 tu vois $(commande), remplace-le par ce que cette commande afficherait si tu l'ex\u00e9cutais.\"</p> <p>Exercice : Comprendre la substitution</p> <ol> <li>Ex\u00e9cutez ces deux commandes et comparez leurs r\u00e9sultats :    <pre><code>echo \"Le PID est $(pidof procstate)\"\necho \"Le PID est pidof procstate\"\n</code></pre></li> <li>Quelle est la diff\u00e9rence ? Pourquoi ?</li> <li>Inventez votre propre commande utilisant <code>$(...)</code> avec une autre commande Linux que vous connaissez.</li> </ol>"},{"location":"activites/etats/#partie-2-observer-les-etats-des-processus","title":"Partie 2 : Observer les \u00e9tats des processus","text":""},{"location":"activites/etats/#les-etats-le-cycle-de-vie-dun-processus","title":"Les \u00e9tats : Le cycle de vie d'un processus","text":"<p>Un processus n'est pas toujours en train de calculer. Comme nous les humains, il peut \u00eatre dans diff\u00e9rents \u00e9tats :</p> <ol> <li>En cours d'ex\u00e9cution (Running - <code>R</code>) : </li> <li>Le processus est actuellement en train de calculer</li> <li> <p>Comme quand vous \u00eates concentr\u00e9 sur un calcul mental</p> </li> <li> <p>En sommeil (Sleeping - <code>S</code>) :</p> </li> <li>Le processus attend quelque chose (une entr\u00e9e, un timer...)</li> <li> <p>Comme quand vous attendez le bus - vous ne faites rien mais vous \u00eates pr\u00eat \u00e0 r\u00e9agir</p> </li> <li> <p>Suspendu (Stopped - <code>T</code>) :</p> </li> <li>Le processus est temporairement arr\u00eat\u00e9</li> <li>Comme quand vous mettez une vid\u00e9o en pause</li> </ol> <pre><code>stateDiagram-v2\n    [*] --&gt; Ready : Cr\u00e9ation\n    Ready --&gt; Running : S\u00e9lection\n    Running --&gt; Ready : Pr\u00e9emption\n    Running --&gt; Sleeping : Attente E/S\n    Sleeping --&gt; Ready : E/S termin\u00e9e\n    Running --&gt; Stopped : Signal STOP\n    Stopped --&gt; Ready : Signal CONT\n\n    note right of Ready : Pr\u00eat \u00e0 s'ex\u00e9cuter\n    note right of Running : En train de calculer\n    note right of Sleeping : En attente\n    note right of Stopped : En pause</code></pre> <p>Ce diagramme montre comment un processus passe d'un \u00e9tat \u00e0 l'autre :</p> <ul> <li>Quand il est cr\u00e9\u00e9, il est d'abord pr\u00eat \u00e0 s'ex\u00e9cuter</li> <li>Le syst\u00e8me le s\u00e9lectionne pour s'ex\u00e9cuter (\u00e9tat Running)</li> <li>S'il doit attendre quelque chose, il passe en Sleeping</li> <li>On peut le mettre en pause (Stopped) et le reprendre plus tard</li> </ul>"},{"location":"activites/etats/#notre-outil-dobservation-lalias-psess","title":"Notre outil d'observation : L'alias psess","text":"<p>Pour observer facilement les processus, nous allons cr\u00e9er un outil personnalis\u00e9. En Linux, on peut cr\u00e9er des raccourcis de commande appel\u00e9s \"alias\". Voici un alias tr\u00e8s utile pour observer les processus :</p> <pre><code># Affiche les processus avec les colonnes essentielles pour une analyse rapide :\n#   - PPID : PID du processus parent.\n#   - PID  : Identifiant du processus.\n#   - STAT : \u00c9tat du processus (Running, Sleeping, etc.).\n#   - TTY  : Terminal associ\u00e9 au processus (ou ? si aucun).\n#   - USER : Utilisateur propri\u00e9taire du processus.\n#   - CMD  : Commande utilis\u00e9e pour d\u00e9marrer le processus.\nalias psess='ps -o ppid,pid,stat,tty,user,cmd'\n</code></pre> <p>C'est comme cr\u00e9er notre propre loupe d'observation, sp\u00e9cialement adapt\u00e9e pour voir ce qui nous int\u00e9resse dans les processus.</p> <p>Conseil pratique</p> <p>Pour garder cet outil toujours disponible, ajoutez cette ligne dans votre fichier <code>~/.bashrc</code>.  C'est comme ranger notre loupe dans un tiroir facilement accessible !</p>"},{"location":"activites/etats/#observer-notre-processus","title":"Observer notre processus","text":"<p>Maintenant que nous avons notre outil, observons notre processus :</p> <pre><code>psess -p $(pidof procstate)\n</code></pre> <p>Exercice d'observation</p> <p>Observez pendant au moins 30 secondes et notez : 1. Les diff\u00e9rents \u00e9tats que vous voyez dans la colonne STAT 2. \u00c0 quel moment de l'affichage du programme ils correspondent 3. Le PPID (Process Parent ID) - qui est le \"parent\" de notre processus ?</p> <p>Analysons chaque colonne de la sortie :</p> <ul> <li>PPID : Le PID du processus qui a cr\u00e9\u00e9 celui-ci (g\u00e9n\u00e9ralement votre shell)</li> <li>PID : L'identifiant unique de notre processus</li> <li>STAT : L'\u00e9tat actuel (R, S, ou T)</li> <li>TTY : Le terminal associ\u00e9</li> <li>USER : Qui a lanc\u00e9 le processus</li> <li>CMD : La commande qui tourne</li> </ul>"},{"location":"activites/etats/#observation-en-temps-reel-avec-htop","title":"Observation en temps r\u00e9el avec htop","text":"<p>Pour une vue plus dynamique, nous pouvons utiliser htop :</p> <pre><code>htop -p $(pidof procstate)\n</code></pre> <p>htop nous montre :</p> <ul> <li>L'utilisation CPU en temps r\u00e9el</li> <li>L'\u00e9tat du processus qui change</li> <li>La m\u00e9moire utilis\u00e9e</li> <li>Et bien d'autres informations</li> </ul> <p>Navigation dans htop</p> <ul> <li>F4 : Filtre pour voir uniquement certains processus</li> <li>Q : Quitter htop</li> <li>Les barres de couleur montrent l'intensit\u00e9 d'utilisation du CPU</li> </ul>"},{"location":"activites/etats/#partie-3-premiers-pas-dans-la-manipulation-des-processus","title":"Partie 3 : Premiers pas dans la manipulation des processus","text":"<p>Maintenant que nous savons observer, essayons d'influencer le comportement de notre processus.</p> <p>Note importante</p> <p>Dans ce sc\u00e9nario, nous allons simplement voir comment \"mettre en pause\" un processus. Les signaux et la commande kill seront expliqu\u00e9s en d\u00e9tail dans les prochains sc\u00e9narios. Pour l'instant, consid\u00e9rez les commandes suivantes comme des \"formules magiques\" que nous comprendrons mieux plus tard.</p>"},{"location":"activites/etats/#mettre-un-processus-en-pause","title":"Mettre un processus en pause","text":"<p>Dans le sc\u00e9nario pr\u00e9c\u00e9dent, nous avons vu comment suspendre un processus avec Ctrl+Z et le reprendre avec les commandes <code>fg</code> et <code>bg</code>. Ici, nous allons d\u00e9couvrir une autre m\u00e9thode qui ne n\u00e9cessite pas d'avoir acc\u00e8s au terminal o\u00f9 le processus s'ex\u00e9cute.</p> <p>Pour suspendre temporairement notre processus depuis n'importe quel terminal :</p> <pre><code>kill -STOP $(pidof procstate)\n</code></pre> <p>Cette commande utilise la substitution que nous avons apprise pr\u00e9c\u00e9demment pour envoyer un signal STOP au bon processus.</p> <p>V\u00e9rifiez imm\u00e9diatement l'\u00e9tat :</p> <pre><code>psess -p $(pidof procstate)\n</code></pre> <p>Vous devriez voir l'\u00e9tat 'T' (Stopped).</p>"},{"location":"activites/etats/#reprendre-lexecution","title":"Reprendre l'ex\u00e9cution","text":"<p>Pour faire reprendre le processus :</p> <pre><code>kill -CONT $(pidof procstate)\n</code></pre> <p>Exercice final de synth\u00e8se</p> <ol> <li>Lancez deux instances de procstate dans des terminaux diff\u00e9rents</li> <li>Observez leurs \u00e9tats avec psess</li> <li>Mettez-en un en pause avec kill -STOP</li> <li>Que remarquez-vous ?<ul> <li>L'autre instance continue-t-elle de fonctionner ?</li> <li>Les PID sont-ils diff\u00e9rents ?</li> <li>Les \u00e9tats sont-ils ind\u00e9pendants ?</li> </ul> </li> </ol>"},{"location":"activites/etats/#conclusion-et-prochaines-etapes","title":"Conclusion et prochaines \u00e9tapes","text":"<p>Nous avons d\u00e9couvert :</p> <ul> <li>Comment identifier un processus avec son PID</li> <li>Les diff\u00e9rents \u00e9tats qu'un processus peut prendre</li> <li>Comment observer ces \u00e9tats</li> <li>Comment mettre en pause et reprendre un processus</li> </ul> <p>Dans les prochains sc\u00e9narios, nous approfondirons :</p> <ul> <li>Les signaux et la commande kill en d\u00e9tail</li> <li>Les \u00e9tats sp\u00e9ciaux comme les zombies</li> <li>Et bien d'autres aspects passionnants des processus Linux !</li> </ul> <p>Questions de r\u00e9flexion finale</p> <ol> <li>Pourquoi un processus passe-t-il en \u00e9tat Sleeping ?</li> <li>Un processus en \u00e9tat Stopped consomme-t-il du CPU ?</li> <li>Que pourrait-il se passer si on ferme le terminal d'un processus suspendu ?</li> </ol>"},{"location":"activites/etats_instr/","title":"Sc\u00e9nario p\u00e9dagogique : D\u00e9couvrir le PID et l'\u00e9tat des processus","text":""},{"location":"activites/etats_instr/#objectifs","title":"Objectifs","text":"<ol> <li>Comprendre le r\u00f4le du PID : Identifier un processus sp\u00e9cifique via son PID.</li> <li>Observer et comprendre les \u00e9tats des processus (<code>R</code>, <code>S</code>, <code>T</code>).</li> <li>D\u00e9couvrir et utiliser des commandes essentielles pour diagnostiquer les processus.</li> </ol>"},{"location":"activites/etats_instr/#introduction-pour-les-etudiants","title":"Introduction pour les \u00e9tudiants","text":"<p>Pr\u00e9sentez les concepts de PID et d\u2019\u00e9tat des processus :</p> <ul> <li>PID : Chaque processus actif sur un syst\u00e8me Linux a un identifiant unique appel\u00e9 PID (Process ID).</li> <li>\u00c9tats (<code>R</code>, <code>S</code>, <code>T</code>) :</li> <li><code>R</code> (Running) : Le processus est actif et utilise le CPU.</li> <li><code>S</code> (Sleeping) : Le processus est inactif, en attente d\u2019un \u00e9v\u00e9nement.</li> <li><code>T</code> (Stopped) : Le processus est suspendu (volontairement, par un signal <code>STOP</code>).</li> </ul> <p>Le programme <code>procstate</code> alterne entre deux \u00e9tats :</p> <ol> <li>Une phase BUSY o\u00f9 il consomme activement le CPU (\u00e9tat <code>R</code>).</li> <li>Une phase SLEEP o\u00f9 il attend (\u00e9tat <code>S</code>).</li> </ol>"},{"location":"activites/etats_instr/#deroule-pedagogique","title":"D\u00e9roul\u00e9 p\u00e9dagogique","text":""},{"location":"activites/etats_instr/#etape-1-lancer-le-programme","title":"\u00c9tape 1 : Lancer le programme","text":"<ol> <li>Dites aux \u00e9tudiants de lancer <code>procstate</code> :</li> </ol> <pre><code>./procstate\n</code></pre> <ol> <li>Question :</li> <li> <p>Que voyez-vous dans le terminal\u202f? (Le programme affiche son PID et alterne entre deux phases.)</p> </li> <li> <p>Expliquez que le PID affich\u00e9 peut \u00eatre utilis\u00e9 pour manipuler et observer le processus dans les manipulations qui vont suivre.</p> </li> </ol>"},{"location":"activites/etats_instr/#etape-2-identifier-le-pid","title":"\u00c9tape 2 : Identifier le PID","text":"<ol> <li> <p>Trouver le PID avec <code>pidof</code> :     Demandez aux \u00e9tudiants d\u2019utiliser la commande suivante :</p> <pre><code>pidof procstate\n</code></pre> <p>Question : - Quel est le PID du programme <code>procstate</code>\u202f?</p> </li> <li> <p>V\u00e9rifier avec <code>ps</code> :     Les \u00e9tudiants peuvent confirmer le PID et voir les d\u00e9tails du processus</p> <p>Pour faciliter l\u2019analyse, vous pouvez cr\u00e9er un alias <code>psess</code> pour afficher les colonnes essentielles :</p> <pre><code># Affiche les processus avec les colonnes essentielles pour une analyse rapide :\n#   - PPID : PID du processus parent.\n#   - PID  : Identifiant du processus.\n#   - STAT : \u00c9tat du processus (Running, Sleeping, etc.).\n#   - TTY  : Terminal associ\u00e9 au processus (ou ? si aucun).\n#   - USER : Utilisateur propri\u00e9taire du processus.\n#   - CMD  : Commande utilis\u00e9e pour d\u00e9marrer le processus.\nalias psess='ps -o ppid,pid,stat,tty,user,cmd' # Affichage des processus avec les colonnes essentielles\n</code></pre> <p>Expliquer la syntaxe de <code>$(pidof procstate)</code> pour remplacer le PID dans la commande <code>ps</code>.</p> <pre><code>psess -p $(pidof procstate)\n</code></pre> <p>Question : - Quel est l\u2019\u00e9tat (<code>STAT</code>) du processus actuellement\u202f? (Essayez pendant les phases BUSY et SLEEP.)</p> </li> </ol>"},{"location":"activites/etats_instr/#etape-3-observer-en-temps-reel-avec-htop","title":"\u00c9tape 3 : Observer en temps r\u00e9el avec <code>htop</code>","text":"<ol> <li>Lancez <code>htop</code> en filtrant sur le programme <code>procstate</code> :</li> </ol> <pre><code>htop -p $(pidof procstate)\n</code></pre> <ol> <li>Actions :</li> <li>Regardez les variations dans l\u2019utilisation CPU entre les phases BUSY et SLEEP.</li> <li> <p>Observez l\u2019\u00e9tat (<code>R</code> ou <code>S</code>) du processus dans la colonne correspondante.</p> </li> <li> <p>Question :</p> </li> <li>Que remarquez-vous sur l\u2019utilisation CPU entre les phases\u202f?</li> </ol>"},{"location":"activites/etats_instr/#etape-4-manipuler-letat-avec-des-signaux","title":"\u00c9tape 4 : Manipuler l'\u00e9tat avec des signaux","text":"<ol> <li> <p>Expliquez comment utiliser <code>kill</code> pour modifier l\u2019\u00e9tat d\u2019un processus.</p> </li> <li> <p>Suspendre le processus :    Demandez aux \u00e9tudiants d\u2019envoyer le signal <code>STOP</code> au processus :</p> </li> </ol> <pre><code>kill -STOP $(pidof procstate)\n</code></pre> <p>Observez que le processus passe \u00e0 l\u2019\u00e9tat <code>T</code> (Stopped) avec :</p> <pre><code>ps -o pid,stat,cmd -p $(pidof procstate)\n</code></pre> <ol> <li>Reprendre le processus :    Demandez aux \u00e9tudiants d\u2019envoyer le signal <code>CONT</code> pour relancer le processus :</li> </ol> <pre><code>kill -CONT $(pidof procstate)\n</code></pre> <p>V\u00e9rifiez que le processus reprend son ex\u00e9cution, alternant entre <code>R</code> et <code>S</code>.</p> <ol> <li>Question :</li> <li>Quelle est la diff\u00e9rence entre les \u00e9tats <code>T</code> (Stopped) et <code>S</code> (Sleeping)\u202f?</li> <li>Pourquoi le processus ne consomme-t-il pas de CPU en \u00e9tat <code>T</code>\u202f?</li> </ol>"},{"location":"activites/etats_instr/#synthese-et-conclusion","title":"Synth\u00e8se et conclusion","text":"<ol> <li>R\u00e9vision des concepts :</li> <li>PID : Chaque processus a un identifiant unique, utilis\u00e9 pour le diagnostiquer ou le manipuler.</li> <li> <p>\u00c9tats (<code>R</code>, <code>S</code>, <code>T</code>) :</p> <ul> <li><code>R</code> : Actif et utilise le CPU.</li> <li><code>S</code> : Inactif, en attente d\u2019un \u00e9v\u00e9nement.</li> <li><code>T</code> : Suspendu volontairement.</li> </ul> </li> <li> <p>Commandes apprises :</p> </li> <li><code>pidof</code> : Trouver le PID d\u2019un processus \u00e0 partir de son nom.</li> <li><code>ps</code> : Afficher les d\u00e9tails d\u2019un processus sp\u00e9cifique.</li> <li><code>htop</code> : Observer les processus en temps r\u00e9el.</li> <li><code>kill</code> : Envoyer des signaux pour manipuler un processus.</li> </ol>"},{"location":"activites/etats_instr/#commandes-utilisees-dans-le-scenario","title":"Commandes utilis\u00e9es dans le sc\u00e9nario","text":"<p>Les alias facilitent l\u2019utilisation des commandes suivantes :</p> <ul> <li>Trouver le PID :</li> </ul> <pre><code>pidof procstate\n</code></pre> <ul> <li>Observer un processus sp\u00e9cifique :</li> </ul> <pre><code>ps -o pid,stat,cmd -p $(pidof procstate)\n</code></pre> <ul> <li>Observer en temps r\u00e9el :</li> </ul> <pre><code>htop -p $(pidof procstate)\n</code></pre> <ul> <li>Manipuler le processus :</li> <li>Suspendre : <code>kill -STOP $(pidof procstate)</code></li> <li>Reprendre : <code>kill -CONT $(pidof procstate)</code></li> </ul>"},{"location":"activites/etats_instr/#pour-aller-plus-loin","title":"Pour aller plus loin","text":"<p>Quelques signaux utiles</p> <pre><code>SIGTERM : demande \u00ab poliment \u00bb au processus de s'arr\u00eater\n\nSIGKILL : tue le processus (utile lorsque SIGTERM \u00e9choue, ce signal n'est pas \u00ab personnalisable \u00bb)\n\nSIGTSTP : suspend le processus\n\nSIGCONT : relance un processus suspendu\n</code></pre> <p>Remarques</p> <pre><code>CTRL+C a pour effet d'envoyer un signal (SIGINT) au(x) processus courant(s).\n\nCTRL+Z a pour effet d'envoyer le signal SIGTSTP au processus courant.\n\nbg sert en fait \u00e0 envoyer SIGCONT \u00e0 un processus.\n\nfg envoie \u00e9galement SIGCONT au processus, et fait en sorte d'attendre la fin.\n\nOn peut voir que man a personnalis\u00e9 sa r\u00e9ponse \u00e0 SIGINT (le procecuss n'est pas tu\u00e9 lorsqu'on tape CTRL+C).\n</code></pre>"},{"location":"activites/fg-bg/","title":"Sc\u00e9nario : Gestion Foreground/Background","text":"<p>Ce sc\u00e9nario vous permettra de d\u00e9couvrir comment Unix g\u00e8re l'ex\u00e9cution simultan\u00e9e de plusieurs processus dans un m\u00eame terminal. Vous apprendrez \u00e0 manipuler les processus entre le premier plan (foreground) et l'arri\u00e8re-plan (background), et vous comprendrez comment le syst\u00e8me permet cette flexibilit\u00e9.</p>"},{"location":"activites/fg-bg/#objectifs-dapprentissage","title":"Objectifs d'apprentissage","text":"<p>\u00c0 la fin de ce sc\u00e9nario, vous serez capable de :</p> <ul> <li>Identifier visuellement l'\u00e9tat d'ex\u00e9cution d'un processus</li> <li>Manipuler les processus entre premier plan et arri\u00e8re-plan</li> <li>Comprendre la diff\u00e9rence entre suspension et contr\u00f4le de flux</li> <li>G\u00e9rer plusieurs processus simultan\u00e9ment</li> </ul>"},{"location":"activites/fg-bg/#concepts-fondamentaux","title":"Concepts fondamentaux","text":""},{"location":"activites/fg-bg/#premier-plan-et-arriere-plan","title":"Premier plan et arri\u00e8re-plan","text":"<p>Pour comprendre la diff\u00e9rence entre premier plan et arri\u00e8re-plan, reprenons notre analogie du restaurant :</p> <p>L'analogie du restaurant</p> <p>Imaginez un serveur qui s'occupe de plusieurs tables :</p> <ul> <li>La table dont il s'occupe activement est au \"premier plan\" - elle a toute son attention</li> <li>Les autres tables qu'il a en charge sont en \"arri\u00e8re-plan\" - elles attendent leur tour</li> <li>Le serveur ne peut s'occuper activement que d'une seule table \u00e0 la fois</li> <li>M\u00eame quand il ne s'en occupe pas, les clients des autres tables peuvent l'appeler si besoin</li> </ul> <p>Dans un terminal Unix, cela se traduit ainsi :</p> <ul> <li>Un processus au premier plan (foreground) :</li> <li>Monopolise le terminal (comme le serveur avec sa table active)</li> <li>Re\u00e7oit les entr\u00e9es clavier</li> <li> <p>Emp\u00eache l'utilisation du terminal pour d'autres t\u00e2ches</p> </li> <li> <p>Un processus en arri\u00e8re-plan (background) :</p> </li> <li>Continue de s'ex\u00e9cuter sans bloquer le terminal</li> <li>Peut afficher des messages \u00e0 l'\u00e9cran</li> <li>N'emp\u00eache pas l'utilisation du terminal</li> </ul>"},{"location":"activites/fg-bg/#mise-en-pratique","title":"Mise en pratique","text":""},{"location":"activites/fg-bg/#preparation-de-lenvironnement","title":"Pr\u00e9paration de l'environnement","text":"<ol> <li>Lancez Terminator et divisez la fen\u00eatre en deux verticalement avec Ctrl+Shift+E</li> <li>Le terminal de gauche servira \u00e0 lancer et manipuler nos processus</li> <li>Le terminal de droite nous permettra d'observer leur \u00e9tat avec la commande <code>ps</code></li> </ol>"},{"location":"activites/fg-bg/#etape-1-observer-la-suspension-dun-processus","title":"\u00c9tape 1 : Observer la suspension d'un processus","text":"<p>Commen\u00e7ons par comprendre comment fonctionne la suspension d'un processus :</p> <ol> <li> <p>Dans le terminal de gauche, lancez proclab :</p> <pre><code>proclab\n</code></pre> <p>Prenez un moment pour observer :</p> <ul> <li>Une fen\u00eatre graphique s'ouvre avec un compteur qui s'incr\u00e9mente</li> <li>Le temps d'ex\u00e9cution augmente r\u00e9guli\u00e8rement</li> <li>Le terminal est bloqu\u00e9 - vous ne pouvez pas y taper de commandes</li> <li>Le processus est au premier plan</li> </ul> </li> <li> <p>Maintenant, suspendez le processus avec Ctrl+Z     Vous verrez appara\u00eetre un message comme :</p> <pre><code>[1]+ Stopped     proclab\n</code></pre> <p>Observez attentivement ce qui se passe :</p> <ul> <li>Le compteur dans l'interface graphique est compl\u00e8tement fig\u00e9</li> <li>Le temps d'ex\u00e9cution ne change plus</li> <li>Le terminal est redevenu disponible</li> <li>Le processus est suspendu (comme un serveur qui met une table en attente)</li> </ul> </li> <li> <p>V\u00e9rifiez l'\u00e9tat du processus :</p> <pre><code>jobs\n</code></pre> <p>La commande affiche les processus g\u00e9r\u00e9s par le terminal :</p> <pre><code>[1]+ Stopped    proclab\n</code></pre> <p>Le <code>[1]</code> est le num\u00e9ro de job - une identification locale au terminal.</p> </li> <li> <p>Reprenez l'ex\u00e9cution avec :</p> <pre><code>fg\n</code></pre> <p>Observez la reprise :</p> <ul> <li>Le compteur recommence \u00e0 s'incr\u00e9menter</li> <li>Le temps d'ex\u00e9cution reprend</li> <li>Le terminal est \u00e0 nouveau bloqu\u00e9</li> <li>Le processus est revenu au premier plan</li> </ul> </li> </ol> <p>Comprendre la suspension</p> <p>La suspension avec Ctrl+Z arr\u00eate r\u00e9ellement l'ex\u00e9cution du processus. C'est comme mettre le processus en pause compl\u00e8te - aucun calcul n'est effectu\u00e9 pendant ce temps.</p>"},{"location":"activites/fg-bg/#etape-2-gerer-plusieurs-processus","title":"\u00c9tape 2 : G\u00e9rer plusieurs processus","text":"<p>Maintenant que vous avez un processus au premier plan depuis l'\u00e9tape pr\u00e9c\u00e9dente, nous allons apprendre \u00e0 jongler entre plusieurs processus :</p> <ol> <li> <p>Commencez par suspendre le processus actuel avec Ctrl+Z     Le terminal est lib\u00e9r\u00e9 et vous pouvez lancer d'autres instances.</p> </li> <li> <p>Lancez une deuxi\u00e8me instance et suspendez-la imm\u00e9diatement :</p> <pre><code>proclab\n# Observez la nouvelle fen\u00eatre qui s'ouvre\n# Appuyez sur CTRL+Z\n</code></pre> </li> <li> <p>Lancez une troisi\u00e8me instance et suspendez-la aussi :</p> <pre><code>proclab\n# Une troisi\u00e8me fen\u00eatre appara\u00eet\n# Appuyez sur CTRL+Z\n</code></pre> </li> <li> <p>Listez tous vos processus :</p> <pre><code>jobs\n</code></pre> <p>Vous devriez voir :</p> <pre><code>[1]    Stopped    proclab\n[2]-   Stopped    proclab\n[3]+   Stopped    proclab\n</code></pre> <p>Chaque num\u00e9ro correspond \u00e0 une fen\u00eatre sp\u00e9cifique de proclab.</p> </li> <li> <p>Reprenez le deuxi\u00e8me processus :</p> <pre><code>fg %2\n</code></pre> <p>Observez attentivement : - Seule la deuxi\u00e8me fen\u00eatre reprend son animation - Les autres restent fig\u00e9es - Le terminal est bloqu\u00e9 par ce processus</p> </li> </ol> <p>Identifier les fen\u00eatres</p> <p>Quand vous reprenez un processus avec <code>fg %n</code>, regardez quelle fen\u00eatre reprend son animation. Cela vous aide \u00e0 comprendre la correspondance entre les num\u00e9ros de jobs et les fen\u00eatres graphiques.</p>"},{"location":"activites/fg-bg/#etape-3-execution-en-arriere-plan","title":"\u00c9tape 3 : Ex\u00e9cution en arri\u00e8re-plan","text":"<p>Un processus suspendu peut \u00eatre relanc\u00e9 en arri\u00e8re-plan plut\u00f4t qu'au premier plan. Pour l'exp\u00e9rimenter :</p> <ol> <li> <p>Si vous avez un processus au premier plan, suspendez-le avec Ctrl+Z</p> </li> <li> <p>Listez vos processus suspendus :</p> <pre><code>jobs\n</code></pre> </li> <li> <p>Relancez le premier processus en arri\u00e8re-plan :</p> <pre><code>bg %1\n</code></pre> </li> </ol> <p>Observez :</p> <ul> <li>La fen\u00eatre correspondante reprend son animation</li> <li>Le terminal reste disponible</li> <li> <p>Vous pouvez continuer \u00e0 taper des commandes</p> </li> <li> <p>Vous pouvez aussi lancer directement un processus en arri\u00e8re-plan :</p> <pre><code>proclab &amp;\n</code></pre> <p>Le <code>&amp;</code> \u00e0 la fin de la commande indique au shell de lancer le processus directement en arri\u00e8re-plan.</p> </li> </ul>"},{"location":"activites/fg-bg/#etape-4-comprendre-le-controle-de-flux","title":"\u00c9tape 4 : Comprendre le contr\u00f4le de flux","text":"<p>Pour cette derni\u00e8re \u00e9tape, nous allons d\u00e9couvrir une autre forme de contr\u00f4le, diff\u00e9rente de la suspension :</p> <ol> <li> <p>Si vous avez des processus en cours, suspendez-les avec Ctrl+Z</p> </li> <li> <p>Lancez proclab avec l'affichage terminal activ\u00e9 :</p> <pre><code>proclab --terminal-output\n</code></pre> <p>Observez le double affichage :</p> <ul> <li>L'interface graphique montre le compteur</li> <li>Le terminal affiche aussi les valeurs du compteur</li> <li>Les deux sont synchronis\u00e9s</li> </ul> </li> <li> <p>Appuyez sur Ctrl+S</p> <p>Observez la diff\u00e9rence de comportement :</p> <ul> <li>L'affichage dans le terminal se fige</li> <li>L'interface graphique continue de s'actualiser</li> <li>Le processus continue de tourner</li> <li>Le terminal semble bloqu\u00e9</li> </ul> </li> <li> <p>Attendez quelques secondes (5-10) puis appuyez sur Ctrl+Q</p> <p>Observez ce qui se passe :</p> <ul> <li>Le terminal affiche soudainement toutes les valeurs du compteur qu'il n'avait pas pu montrer</li> <li>L'interface graphique n'a jamais \u00e9t\u00e9 affect\u00e9e</li> <li>L'affichage dans le terminal reprend normalement</li> </ul> </li> </ol> <p>CTRL+S vs CTRL+Z</p> <p>Il y a une diff\u00e9rence fondamentale : - Ctrl+Z suspend r\u00e9ellement le processus (il ne s'ex\u00e9cute plus du tout) - Ctrl+S ne fait que geler l'affichage du terminal (le processus continue de s'ex\u00e9cuter)</p>"},{"location":"activites/fg-bg/#etape-5-faire-le-menage","title":"\u00c9tape 5 : Faire le m\u00e9nage","text":"<p>Au fil des \u00e9tapes pr\u00e9c\u00e9dentes, nous avons accumul\u00e9 plusieurs fen\u00eatres proclab suspendues. Il est temps de faire le m\u00e9nage ! Pour cela, nous allons utiliser la commande <code>kill</code> avec les num\u00e9ros de jobs :</p> <ol> <li> <p>Commencez par lister tous les processus encore pr\u00e9sents :     <pre><code>jobs\n</code></pre>     Vous verrez probablement plusieurs processus proclab suspendus ou en arri\u00e8re-plan.</p> </li> <li> <p>Pour terminer un processus sp\u00e9cifique, utilisez <code>kill</code> avec le num\u00e9ro de job :     <pre><code>kill %1   # Termine le job num\u00e9ro 1\n</code></pre></p> <p>Observez :</p> <ul> <li>La fen\u00eatre correspondante se ferme</li> <li>Un message indique que le job est termin\u00e9</li> <li>Le processus dispara\u00eet de la liste des jobs</li> </ul> </li> <li> <p>R\u00e9p\u00e9tez l'op\u00e9ration pour chaque job restant :     <pre><code>kill %2   # Termine le job num\u00e9ro 2\nkill %3   # Termine le job num\u00e9ro 3\n# etc...\n</code></pre></p> </li> <li> <p>V\u00e9rifiez qu'il ne reste plus de processus :     <pre><code>jobs\n</code></pre>     La commande ne devrait plus rien afficher.</p> </li> </ol> <p>Importance du nettoyage</p> <p>Dans un environnement de production, il est crucial de ne pas laisser des processus suspendus ou abandonn\u00e9s. Ils consomment des ressources syst\u00e8me et peuvent cr\u00e9er de la confusion. Prenez l'habitude de toujours faire le m\u00e9nage apr\u00e8s vos manipulations.</p>"},{"location":"activites/fg-bg/#les-signaux-en-jeu","title":"Les signaux en jeu","text":"<p>Ces manipulations reposent sur diff\u00e9rents signaux Unix :</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Running: Lancement\n    Running --&gt; Stopped: SIGTSTP (CTRL+Z)\n    Stopped --&gt; Running: SIGCONT (fg/bg)\n    Running --&gt; [*]: SIGINT (CTRL+C)\n\n    note left of Running\n        Premier plan ou\n        arri\u00e8re-plan\n    end note</code></pre> <ul> <li>SIGTSTP (Terminal Stop) : Envoy\u00e9 par Ctrl+Z, suspend le processus</li> <li>SIGCONT (Continue) : Envoy\u00e9 par <code>fg</code> et <code>bg</code>, reprend l'ex\u00e9cution</li> <li>SIGINT (Interrupt) : Envoy\u00e9 par Ctrl+C, termine le processus</li> </ul>"},{"location":"activites/fg-bg/#points-cles-a-retenir","title":"Points cl\u00e9s \u00e0 retenir","text":"<ol> <li>La suspension (Ctrl+Z) arr\u00eate r\u00e9ellement l'ex\u00e9cution du processus</li> <li>Le contr\u00f4le de flux (Ctrl+S/Ctrl+Q) n'affecte que l'affichage</li> <li>Chaque terminal maintient sa propre liste de jobs</li> <li>Un processus en arri\u00e8re-plan lib\u00e8re le terminal</li> <li>Les processus conservent leur \u00e9tat m\u00eame suspendus</li> </ol>"},{"location":"activites/fg-bg/#exercices-pratiques","title":"Exercices pratiques","text":""},{"location":"activites/fg-bg/#exercice-1-jonglage-de-processus","title":"Exercice 1 : Jonglage de processus","text":"<ol> <li>Lancez trois instances de proclab en arri\u00e8re-plan avec <code>&amp;</code></li> <li>Ramenez-en une au premier plan avec <code>fg</code></li> <li>Suspendez-la avec Ctrl+Z</li> <li>V\u00e9rifiez que les autres continuent en arri\u00e8re-plan</li> </ol>"},{"location":"activites/fg-bg/#exercice-2-observer-les-etats-des-processus","title":"Exercice 2 : Observer les \u00e9tats des processus","text":"<p>Dans le terminal de droite, nous allons observer l'\u00e9tat de nos processus avec diff\u00e9rentes options de ps :</p> <pre><code>ps aux | grep proclab\n</code></pre> <p>Observez la colonne STAT :</p> <ul> <li>'S' indique un processus en sommeil (sleep)</li> <li>'T' indique un processus stopp\u00e9 (stopped)</li> <li>'R' indique un processus en cours d'ex\u00e9cution (running)</li> </ul> <p>Testez les diff\u00e9rentes manipulations dans le terminal de gauche et observez les changements d'\u00e9tat : 1. Suspendez un processus avec Ctrl+Z 2. Reprenez-le en arri\u00e8re-plan avec <code>bg</code> 3. Ramenez-le au premier plan avec <code>fg</code></p>"},{"location":"activites/fg-bg/#prochaine-etape","title":"Prochaine \u00e9tape","text":"<p>Maintenant que vous ma\u00eetrisez la gestion des processus au premier plan et en arri\u00e8re-plan, nous allons explorer un \u00e9tat particulier : les processus zombies.</p>"},{"location":"activites/orphelin/","title":"Sc\u00e9nario : Processus orphelins","text":""},{"location":"activites/orphelin/#objectif-pedagogique","title":"Objectif p\u00e9dagogique","text":"<p>Apprendre \u00e0 identifier, comprendre et manipuler un processus orphelin (orphan process) sous Linux par l\u2019exp\u00e9rimentation. Cette activit\u00e9 permet \u00e9galement de d\u00e9couvrir et d'utiliser des commandes essentielles pour la gestion des processus.</p>"},{"location":"activites/orphelin/#1-introduction-quest-ce-quun-processus-orphelin","title":"1. Introduction : Qu\u2019est-ce qu\u2019un processus orphelin ?","text":""},{"location":"activites/orphelin/#definition","title":"D\u00e9finition","text":"<p>Un processus orphelin (orphan process) est un processus dont le processus parent est mort avant qu'il ne termine son ex\u00e9cution. Sous Linux, lorsqu'un processus parent meurt, ses enfants sont automatiquement adopt\u00e9s par le processus syst\u00e8me <code>init</code> (ou <code>systemd</code> selon la distribution), qui a toujours pour PID <code>1</code>.</p> <p>\u2139\ufe0f Qu\u2019est-ce que <code>init</code> et <code>systemd</code> ? </p> <ul> <li><code>init</code> et <code>systemd</code> sont des programmes essentiels du syst\u00e8me Linux, appel\u00e9s gestionnaires de d\u00e9marrage (init systems).  </li> <li>Leur r\u00f4le principal est de superviser les processus d\u00e8s le d\u00e9marrage du syst\u00e8me et de maintenir le fonctionnement global.  </li> <li>Si un processus perd son parent, <code>init</code> ou <code>systemd</code> en devient le nouveau parent pour garantir qu\u2019aucun processus ne reste sans supervision.  </li> <li>Certaines distributions Linux utilisent <code>init</code> (comme Debian dans ses anciennes versions) tandis que d'autres utilisent <code>systemd</code> (par exemple, Ubuntu et les versions r\u00e9centes de Debian).  </li> <li>Analogie : Pensez \u00e0 <code>init</code> ou <code>systemd</code> comme une \"personne de garde\" qui prend en charge les enfants laiss\u00e9s sans parent. Peu importe qui est en service (<code>init</code> ou <code>systemd</code>), ils assument la responsabilit\u00e9.  </li> </ul> <p>Cette adoption automatique emp\u00eache les processus orphelins de devenir probl\u00e9matiques pour le syst\u00e8me.  </p>"},{"location":"activites/orphelin/#concept-cle","title":"Concept cl\u00e9","text":"<ul> <li>Un processus orphelin n'est pas probl\u00e9matique car il est pris en charge par <code>init</code>.</li> <li>Contrairement aux zombies, les orphelins ne consomment pas inutilement de ressources, car ils continuent \u00e0 \u00eatre g\u00e9r\u00e9s par le syst\u00e8me.</li> </ul>"},{"location":"activites/orphelin/#exemple-concret","title":"Exemple concret","text":"<p>Imaginez un programme (parent) qui effectue une t\u00e2che, comme surveiller un t\u00e9l\u00e9chargement (enfant). Si le parent est tu\u00e9 avant que l'enfant ne termine, le syst\u00e8me adopte l'enfant pour qu'il puisse continuer son ex\u00e9cution.</p>"},{"location":"activites/orphelin/#2-experimentation-guidee","title":"2. Exp\u00e9rimentation guid\u00e9e","text":""},{"location":"activites/orphelin/#preparation","title":"Pr\u00e9paration","text":"<ol> <li> <p>Ouvrir Terminator    Divisez votre terminal en deux colonnes (cliquez droit \u2192 \u00ab Split vertically \u00bb) pour avoir une fen\u00eatre gauche et une fen\u00eatre droite.</p> </li> <li> <p>Lancer le programme    Dans le terminal gauche, ex\u00e9cutez le programme de d\u00e9monstration qui simule les processus orphelins :  </p> </li> </ol> <pre><code>procorphan\n</code></pre> <p>Laissez ce terminal actif pour interagir avec le menu.</p>"},{"location":"activites/orphelin/#etape-1-observer-les-processus-parent-et-enfant","title":"\u00c9tape 1 : Observer les processus parent et enfant","text":"<ol> <li> <p>Dans le terminal droit, affichez la liste des processus en cours d\u2019ex\u00e9cution :  </p> <pre><code>ps -ef | grep procorphan\n</code></pre> <p>Explications :</p> <ul> <li><code>ps</code> : Commande qui affiche une liste des processus actifs.  </li> <li><code>-e</code> : Montre tous les processus en cours sur le syst\u00e8me.  </li> <li><code>-f</code> : Affiche des informations d\u00e9taill\u00e9es, comme les PID, les PPID et les noms des processus.  </li> <li><code>grep procorphan</code> : Filtre les r\u00e9sultats pour ne montrer que ceux contenant le mot \u00ab procorphan \u00bb.</li> </ul> <p>Indice : Identifiez les PID (identifiants) des processus parent et enfant et notez-les.</p> </li> <li> <p>Revenez au terminal gauche. Utilisez le menu pour confirmer les informations sur les processus parent et enfant.</p> </li> </ol>"},{"location":"activites/orphelin/#etape-2-provoquer-un-processus-orphelin","title":"\u00c9tape 2 : Provoquer un processus orphelin","text":"<ol> <li> <p>Revenez au terminal droit et tuez le processus parent :  </p> <pre><code>kill -9 &lt;PID_parent&gt;\n</code></pre> <p>Explications : - <code>kill</code> : Envoie un signal \u00e0 un processus pour le contr\u00f4ler (exemple : le terminer). - <code>-9</code> : Signal SIGKILL, qui force la terminaison imm\u00e9diate du processus. - <code>&lt;PID_parent&gt;</code> : Remplacez <code>&lt;PID_parent&gt;</code> par l\u2019identifiant du processus parent.</p> </li> <li> <p>Affichez \u00e0 nouveau les processus pour observer les changements :  </p> <pre><code>ps -ef | grep procorphan\n</code></pre> <p>Indice : V\u00e9rifiez le PPID (Parent Process ID) du processus enfant. Si l\u2019enfant est orphelin, son PPID sera <code>1</code> (le PID de <code>init</code> ou <code>systemd</code>).</p> </li> </ol>"},{"location":"activites/orphelin/#question-dobservation","title":"Question d\u2019observation","text":"<ul> <li>Que remarquez-vous dans la colonne PPID du processus enfant apr\u00e8s la mort du parent ? (Indice : Le PPID indique que l\u2019enfant est d\u00e9sormais adopt\u00e9 par <code>init</code>.) </li> </ul>"},{"location":"activites/orphelin/#etape-3-continuite-dun-processus-orphelin","title":"\u00c9tape 3 : Continuit\u00e9 d\u2019un processus orphelin","text":"<ol> <li>Observez dans le terminal gauche que l\u2019enfant continue son ex\u00e9cution m\u00eame apr\u00e8s la mort du parent.  </li> <li>Revenez au terminal droit et confirmez qu\u2019un processus orphelin est pris en charge par <code>init</code>.  </li> </ol>"},{"location":"activites/orphelin/#question-danalyse","title":"Question d\u2019analyse","text":"<ul> <li>Pourquoi le syst\u00e8me adopte-t-il un processus orphelin ? (Indice : Cela garantit que tous les processus en cours sont supervis\u00e9s.)</li> </ul>"},{"location":"activites/orphelin/#exercice-1-comprendre-la-commande-ps","title":"Exercice 1 : Comprendre la commande <code>ps</code>","text":"<p>Dans le terminal droit, ex\u00e9cutez les commandes suivantes et comparez leurs r\u00e9sultats :  </p> <ol> <li>Liste compl\u00e8te des processus avec <code>ps</code> :  </li> </ol> <pre><code>ps -e\n</code></pre> <ol> <li>Affichage d\u00e9taill\u00e9 :  </li> </ol> <pre><code>ps -ef\n</code></pre> <ol> <li>Filtrage des processus li\u00e9s \u00e0 <code>procorphan</code> :  </li> </ol> <pre><code>ps -ef | grep procorphan\n</code></pre>"},{"location":"activites/orphelin/#questions","title":"Questions","text":"<ul> <li>Quelle commande montre les relations entre les processus (PID et PPID) ?  </li> <li>Quelle commande permet d\u2019afficher uniquement les processus li\u00e9s \u00e0 un programme sp\u00e9cifique ?  </li> </ul>"},{"location":"activites/orphelin/#exercice-2-experimenter-avec-plusieurs-enfants","title":"Exercice 2 : Exp\u00e9rimenter avec plusieurs enfants","text":"<ol> <li>Relancez <code>procorphan</code>.  </li> <li>Modifiez le menu pour cr\u00e9er plusieurs enfants.  </li> <li>Tuez le parent et observez les PPID des enfants.  </li> </ol>"},{"location":"activites/orphelin/#questions_1","title":"Questions","text":"<ul> <li>Que se passe-t-il pour les enfants apr\u00e8s la mort du parent ?  </li> <li>Comment v\u00e9rifier qu\u2019ils sont maintenant adopt\u00e9s par <code>init</code> ?  </li> </ul>"},{"location":"activites/orphelin/#exercice-3-reflexion-critique","title":"Exercice 3 : R\u00e9flexion critique","text":"<ol> <li>Expliquez pourquoi les processus orphelins ne posent pas de probl\u00e8me au syst\u00e8me.  </li> <li>Quelle diff\u00e9rence fondamentale existe-t-il entre un zombie et un orphelin ?  </li> </ol>"},{"location":"activites/orphelin/#4-resume-des-points-cles","title":"4. R\u00e9sum\u00e9 des points cl\u00e9s","text":"<ul> <li>Un processus orphelin survient lorsqu\u2019un parent meurt avant son enfant.  </li> <li>Sous Linux, les orphelins sont automatiquement adopt\u00e9s par <code>init</code> (PID = 1).  </li> <li>Les processus orphelins continuent \u00e0 fonctionner normalement et ne consomment pas de ressources inutiles.  </li> <li>Utilisez <code>ps</code> pour v\u00e9rifier le PPID des processus et observer les relations entre parent et enfant.</li> </ul>"},{"location":"activites/orphelin/#5-evaluation-des-connaissances","title":"5. \u00c9valuation des connaissances","text":""},{"location":"activites/orphelin/#questions-a-choix-multiples","title":"Questions \u00e0 choix multiples","text":"<p>Q1 : Que devient un processus enfant lorsque son parent meurt ? </p> <ol> <li>Il est adopt\u00e9 par <code>init</code>.  </li> <li>Il est arr\u00eat\u00e9 imm\u00e9diatement.  </li> <li>Il devient un zombie.  </li> </ol> <p>R\u00e9ponse attendue : 1.  </p> <p>Q2 : Quels outils permettent d\u2019observer les processus orphelins sous Linux ? </p> <ol> <li><code>htop</code> </li> <li><code>ps</code> </li> <li><code>kill</code> </li> <li><code>grep</code> </li> </ol> <p>R\u00e9ponses attendues : 1, 2 et 4.  </p> <p>Q3 : Quelle est la diff\u00e9rence entre un zombie et un orphelin ? </p> <ol> <li>Un zombie a encore son parent actif.  </li> <li>Un zombie n\u2019est pas adopt\u00e9 par <code>init</code>.  </li> <li>Un orphelin consomme des ressources inutilement.  </li> </ol> <p>R\u00e9ponse attendue : 1 et 2.</p>"},{"location":"activites/orphelin/#6-lien-avec-les-notions-futures","title":"6. Lien avec les notions futures","text":"<ul> <li>Processus zombies : Comparez avec les processus zombies \u00e9tudi\u00e9s dans une activit\u00e9 pr\u00e9c\u00e9dente.  </li> <li>Gestion des processus par le syst\u00e8me : \u00c9tudiez comment <code>init</code> et <code>systemd</code> supervisent les processus pour assurer la stabilit\u00e9 du syst\u00e8me.</li> </ul>"},{"location":"activites/orphelin/#notes-pedagogiques","title":"Notes p\u00e9dagogiques","text":"<p>Cette activit\u00e9 permet aux \u00e9tudiants d\u2019exp\u00e9rimenter les processus orphelins tout en d\u00e9couvrant des commandes essentielles (<code>ps</code>, <code>kill</code>, <code>grep</code>). Les questions et indices guident l\u2019apprentissage actif et favorisent une r\u00e9flexion approfondie. Vous pouvez enrichir l\u2019activit\u00e9 avec des diagrammes pour visualiser les relations parent-enfant dans les processus Linux.  </p>"},{"location":"activites/priorites/","title":"Sc\u00e9nario : Processus orphelins","text":"<p>Voici un programme en C, nomm\u00e9 <code>procprio</code>, qui permet d\u2019exp\u00e9rimenter la gestion des priorit\u00e9s sous Linux avec les commandes <code>nice</code> et <code>renice</code>. Le programme ex\u00e9cute une t\u00e2che CPU-intensive (par exemple, un calcul simple dans une boucle infinie) pour illustrer comment les priorit\u00e9s influencent son comportement.</p>"},{"location":"activites/priorites/#fonctionnement-du-programme","title":"Fonctionnement du programme","text":"<ol> <li>Objectif du programme :</li> <li>Simuler un processus qui effectue une t\u00e2che CPU-intensive.</li> <li> <p>Afficher r\u00e9guli\u00e8rement le PID, la priorit\u00e9 (via la commande <code>getpriority</code>), et un compteur.</p> </li> <li> <p>Options du programme :</p> </li> <li> <p>Le programme accepte un argument optionnel pour d\u00e9finir la priorit\u00e9 initiale via <code>nice</code> :      <pre><code>./procprio &lt;valeur_nice&gt;\n</code></pre></p> </li> <li> <p>Ex\u00e9cution sans argument :</p> </li> <li>La priorit\u00e9 par d\u00e9faut (<code>nice = 0</code>) est utilis\u00e9e.</li> </ol>"},{"location":"activites/priorites/#instructions-pedagogiques-pour-le-scenario","title":"Instructions p\u00e9dagogiques pour le sc\u00e9nario","text":""},{"location":"activites/priorites/#etape-1-lancer-plusieurs-instances-de-procprio","title":"\u00c9tape 1 : Lancer plusieurs instances de <code>procprio</code>","text":"<ol> <li>Ouvrez Terminator et divisez le terminal en plusieurs colonnes.</li> <li>Lancez plusieurs instances du programme avec diff\u00e9rentes valeurs de <code>nice</code> :</li> <li>Exemple :      <pre><code>./procprio 0\n./procprio 10\n./procprio 19\n</code></pre></li> <li>Observez les processus dans un autre terminal avec <code>htop</code> ou <code>ps</code> :    <pre><code>htop\n</code></pre></li> <li>Utilisez la touche <code>F3</code> dans <code>htop</code> pour rechercher les processus <code>procprio</code>.</li> <li>Regardez la colonne <code>NI</code> pour voir les priorit\u00e9s.</li> </ol>"},{"location":"activites/priorites/#etape-2-modifier-les-priorites-avec-renice","title":"\u00c9tape 2 : Modifier les priorit\u00e9s avec <code>renice</code>","text":"<ol> <li> <p>Trouvez le PID des processus <code>procprio</code> :    <pre><code>ps -ef | grep procprio\n</code></pre></p> </li> <li> <p>Ajustez les priorit\u00e9s avec la commande <code>renice</code> :</p> </li> <li>Exemple pour r\u00e9duire la priorit\u00e9 d\u2019un processus :      <pre><code>sudo renice 5 -p &lt;PID&gt;\n</code></pre></li> <li> <p>Exemple pour augmenter la priorit\u00e9 d\u2019un processus (n\u00e9cessite <code>sudo</code>) :      <pre><code>sudo renice -10 -p &lt;PID&gt;\n</code></pre></p> </li> <li> <p>Revenez \u00e0 <code>htop</code> ou <code>ps</code> pour v\u00e9rifier les changements dans la colonne <code>NI</code>.</p> </li> </ol>"},{"location":"activites/priorites/#etape-3-observer-limpact-des-priorites","title":"\u00c9tape 3 : Observer l\u2019impact des priorit\u00e9s","text":"<ol> <li>Surveillez les sorties des diff\u00e9rentes instances de <code>procprio</code>.</li> <li>Les processus avec une priorit\u00e9 plus \u00e9lev\u00e9e (valeur <code>nice</code> plus basse) devraient progresser plus rapidement.</li> <li> <p>Les processus avec une priorit\u00e9 plus basse (valeur <code>nice</code> plus haute) devraient ralentir.</p> </li> <li> <p>Analysez les ressources CPU utilis\u00e9es par chaque processus dans <code>htop</code>.</p> </li> <li>La colonne <code>%CPU</code> indique l\u2019utilisation du processeur.</li> </ol>"},{"location":"activites/priorites/#exercices-pratiques","title":"Exercices pratiques","text":"<ol> <li>Exp\u00e9rience avec <code>nice</code> :</li> <li>Lancez deux instances de <code>procprio</code> :      <pre><code>./procprio 0\n./procprio 19\n</code></pre></li> <li> <p>Observez leurs performances respectives dans <code>htop</code>.</p> </li> <li> <p>Exp\u00e9rience avec <code>renice</code> :</p> </li> <li>Lancez une instance de <code>procprio</code> avec une priorit\u00e9 \u00e9lev\u00e9e (<code>nice = -5</code>).</li> <li>Pendant son ex\u00e9cution, changez sa priorit\u00e9 avec <code>renice</code> pour la diminuer.<ul> <li>Exemple :    <pre><code>sudo renice 10 -p &lt;PID&gt;\n</code></pre></li> </ul> </li> <li> <p>Observez comment cela affecte son utilisation CPU.</p> </li> <li> <p>Analyse comparative :</p> </li> <li>Comparez l\u2019impact des priorit\u00e9s sur des processus utilisant intensivement le CPU.</li> <li>D\u00e9terminez comment <code>nice</code> et <code>renice</code> influencent les performances globales du syst\u00e8me.</li> </ol>"},{"location":"activites/priorites/#tableau-recapitulatif-des-commandes","title":"Tableau r\u00e9capitulatif des commandes","text":"Commande Explication <code>nice &lt;valeur&gt; &lt;commande&gt;</code> Lance une commande avec une priorit\u00e9 d\u00e9finie. La valeur <code>nice</code> va de -20 (priorit\u00e9 haute) \u00e0 19 (priorit\u00e9 basse). <code>renice &lt;valeur&gt; -p &lt;PID&gt;</code> Modifie la priorit\u00e9 d\u2019un processus en cours. N\u00e9cessite <code>sudo</code> pour diminuer la valeur <code>nice</code>. <code>ps -o pid,ni,cmd</code> Affiche les priorit\u00e9s (<code>NI</code>) des processus en cours. <code>htop</code> Affiche un moniteur interactif des processus, avec la colonne <code>NI</code> pour les priorit\u00e9s."},{"location":"activites/priorites/#questions-de-reflexion","title":"Questions de r\u00e9flexion","text":"<ol> <li>Observation des priorit\u00e9s :</li> <li>Comment \u00e9voluent les performances d\u2019un processus lorsque sa valeur <code>nice</code> est augment\u00e9e ?</li> <li> <p>Pourquoi une priorit\u00e9 plus basse (valeur <code>nice</code> plus \u00e9lev\u00e9e) diminue-t-elle l\u2019utilisation CPU d\u2019un processus ?</p> </li> <li> <p>Exp\u00e9rience avec <code>renice</code> :</p> </li> <li>Comment les changements de priorit\u00e9 influencent-ils imm\u00e9diatement un processus ?</li> <li> <p>Pourquoi faut-il des privil\u00e8ges administratifs pour diminuer une valeur <code>nice</code> (augmenter la priorit\u00e9) ?</p> </li> <li> <p>Impact sur les performances globales :</p> </li> <li>Que se passe-t-il si plusieurs processus ont des priorit\u00e9s similaires et utilisent intensivement le CPU ?</li> <li>Dans quels sc\u00e9narios r\u00e9els utiliseriez-vous <code>nice</code> ou <code>renice</code> pour optimiser un syst\u00e8me ?</li> </ol>"},{"location":"activites/priorites/#resume-des-points-cles","title":"R\u00e9sum\u00e9 des points cl\u00e9s","text":"<ul> <li>La priorit\u00e9 d\u2019un processus d\u00e9termine son acc\u00e8s au CPU. Une priorit\u00e9 plus \u00e9lev\u00e9e (valeur <code>nice</code> plus basse) lui accorde plus de temps processeur.</li> <li><code>nice</code> est utilis\u00e9 pour d\u00e9finir la priorit\u00e9 d\u2019un processus au d\u00e9marrage, tandis que <code>renice</code> permet de la modifier apr\u00e8s le d\u00e9marrage.</li> <li>Des outils comme <code>htop</code> permettent de visualiser facilement l\u2019impact des priorit\u00e9s sur les processus en cours.</li> </ul>"},{"location":"activites/priorites/#evaluation-des-connaissances","title":"\u00c9valuation des connaissances","text":"<ol> <li>Que signifie une valeur <code>nice</code> \u00e9lev\u00e9e (par exemple, 19) ?</li> <li>Priorit\u00e9 haute.</li> <li>Priorit\u00e9 basse.</li> <li>Priorit\u00e9 neutre.</li> </ol> <p>R\u00e9ponse attendue : 2.</p> <ol> <li>Pourquoi faut-il utiliser <code>sudo</code> pour diminuer une valeur <code>nice</code> ?</li> <li>Cela r\u00e9duit les privil\u00e8ges du processus.</li> <li>Cela augmente la priorit\u00e9 du processus, ce qui peut affecter le syst\u00e8me globalement.</li> <li>Cela ne n\u00e9cessite pas <code>sudo</code>.</li> </ol> <p>R\u00e9ponse attendue : 2.</p> <ol> <li>Quel outil interactif affiche la colonne <code>NI</code> pour visualiser les priorit\u00e9s ?</li> <li><code>ps</code></li> <li><code>htop</code></li> <li><code>nice</code></li> </ol> <p>R\u00e9ponse attendue : 2.</p>"},{"location":"activites/signaux/","title":"Sc\u00e9nario : Signaux","text":""},{"location":"activites/signaux/#objectif-pedagogique","title":"Objectif p\u00e9dagogique","text":"<p>D\u00e9couvrir et exp\u00e9rimenter le fonctionnement des signaux sous Linux. Les \u00e9tudiants apprendront \u00e0 identifier, envoyer et intercepter des signaux \u00e0 l'aide d'un programme interactif \u00e9crit en C et de commandes comme <code>kill</code> et <code>stty</code>.</p>"},{"location":"activites/signaux/#1-introduction-quest-ce-quun-signal-sous-linux","title":"1. Introduction : Qu\u2019est-ce qu\u2019un signal sous Linux ?","text":""},{"location":"activites/signaux/#definition","title":"D\u00e9finition","text":"<p>Un signal est un m\u00e9canisme utilis\u00e9 par Linux pour envoyer une notification \u00e0 un processus. Les signaux permettent de communiquer avec un processus, qu\u2019il soit au premier plan ou en arri\u00e8re-plan. Ils peuvent, par exemple : - Arr\u00eater un processus, comme avec <code>CTRL+C</code>. - Mettre un processus en pause ou le reprendre. - Envoyer une commande utilisateur pour effectuer une t\u00e2che sp\u00e9cifique.</p>"},{"location":"activites/signaux/#concept-cle","title":"Concept cl\u00e9","text":"<p>Les signaux sont identifi\u00e9s par un nom (par exemple, <code>SIGINT</code>) et un num\u00e9ro (par exemple, <code>2</code>). - Certains signaux sont g\u00e9n\u00e9r\u00e9s par le syst\u00e8me (comme <code>SIGHUP</code> lorsque vous fermez un terminal). - D'autres peuvent \u00eatre envoy\u00e9s manuellement par un utilisateur, via la commande <code>kill</code> ou des touches clavier.  </p>"},{"location":"activites/signaux/#analogie","title":"Analogie","text":"<p>Pensez aux signaux comme des messages envoy\u00e9s \u00e0 un employ\u00e9 (le processus) : - <code>SIGINT</code> : \u00ab Arr\u00eate ce que tu fais imm\u00e9diatement ! \u00bb - <code>SIGUSR1</code> : \u00ab Voici une t\u00e2che sp\u00e9ciale \u00e0 effectuer. \u00bb - <code>SIGKILL</code> : \u00ab Je suis le patron, tu es vir\u00e9 imm\u00e9diatement. \u00bb  </p>"},{"location":"activites/signaux/#2-experimentation-guidee","title":"2. Exp\u00e9rimentation guid\u00e9e","text":""},{"location":"activites/signaux/#preparation","title":"Pr\u00e9paration","text":"<ol> <li>Ouvrir Terminator    Divisez votre terminal en deux colonnes (cliquez droit \u2192 \u00ab Split vertically \u00bb).  </li> <li>Terminal gauche : Lancez le programme interactif.  </li> <li> <p>Terminal droit : Envoyez des signaux au programme.  </p> </li> <li> <p>Lancer le programme    Dans le terminal gauche : <pre><code>./signal_demo\n</code></pre></p> </li> </ol>"},{"location":"activites/signaux/#etape-1-decouvrir-les-signaux-envoyes-par-le-clavier","title":"\u00c9tape 1 : D\u00e9couvrir les signaux envoy\u00e9s par le clavier","text":"<ol> <li>Utiliser <code>stty</code> pour explorer les raccourcis clavier    Dans le terminal gauche : <pre><code>stty -a\n</code></pre></li> </ol> <p>#### Explications :    - <code>stty -a</code> : Affiche les configurations du terminal, notamment les raccourcis clavier pour envoyer des signaux.    - Recherchez les lignes comme : <pre><code>intr = ^C; quit = ^\\; susp = ^Z\n</code></pre>      - <code>intr</code> (<code>^C</code>) : Interrompt un processus (envoie <code>SIGINT</code>).      - <code>quit</code> (<code>^\\</code>) : Arr\u00eate un processus et g\u00e9n\u00e8re un vidage m\u00e9moire (envoie <code>SIGQUIT</code>).      - <code>susp</code> (<code>^Z</code>) : Met un processus en pause (envoie <code>SIGTSTP</code>).</p> <p>Question : Quels signaux peuvent \u00eatre envoy\u00e9s par le clavier ? </p> <p>Indice : Regardez les noms et raccourcis associ\u00e9s dans la sortie de la commande <code>stty -a</code>. Par exemple, <code>intr = ^C</code> correspond \u00e0 <code>CTRL+C</code>, qui envoie un signal.  </p> <ol> <li>Tester les signaux depuis le clavier </li> <li>Dans le terminal gauche, appuyez sur <code>CTRL+C</code>. Que se passe-t-il ?  </li> <li>Appuyez sur <code>CTRL+Z</code>.  </li> <li>Essayez <code>CTRL+\\</code>.  </li> </ol>"},{"location":"activites/signaux/#question-dobservation","title":"Question d\u2019observation","text":"<ul> <li>Que fait le programme en r\u00e9ponse \u00e0 ces signaux ?  </li> <li>Pourquoi certains signaux (comme <code>CTRL+\\</code>) provoquent-ils une action plus brutale que d\u2019autres ?</li> </ul>"},{"location":"activites/signaux/#etape-2-envoyer-des-signaux-avec-la-commande-kill","title":"\u00c9tape 2 : Envoyer des signaux avec la commande <code>kill</code>","text":"<ol> <li>Identifier le processus actif    Dans le terminal droit, utilisez <code>ps</code> pour lister les processus en cours : <pre><code>ps -ef | grep signal_demo\n</code></pre></li> </ol> <p>#### Explications :    - <code>ps -ef</code> : Affiche tous les processus actifs avec des informations d\u00e9taill\u00e9es.    - <code>grep signal_demo</code> : Filtre la liste pour ne montrer que les processus li\u00e9s au programme.  </p> <p>Indice : Notez le PID (identifiant) du processus <code>signal_demo</code>.</p> <ol> <li>Envoyer des signaux au processus </li> <li>Envoyez le signal <code>SIGUSR1</code> pour demander un nombre al\u00e9atoire : <pre><code>kill -USR1 &lt;PID&gt;\n</code></pre></li> <li>Envoyez le signal <code>SIGUSR2</code> pour une citation humoristique : <pre><code>kill -USR2 &lt;PID&gt;\n</code></pre></li> <li> <p>Essayez d\u2019envoyer <code>SIGTERM</code> : <pre><code>kill -TERM &lt;PID&gt;\n</code></pre></p> <p>Question : Comment le programme r\u00e9agit-il \u00e0 chaque signal ? </p> <p>Indice : Observez les messages affich\u00e9s dans le terminal gauche apr\u00e8s avoir envoy\u00e9 les signaux (<code>SIGUSR1</code>, <code>SIGUSR2</code>, etc.). Chaque signal d\u00e9clenche une action sp\u00e9cifique.  </p> </li> </ol>"},{"location":"activites/signaux/#etape-3-comprendre-les-signaux-non-interceptables","title":"\u00c9tape 3 : Comprendre les signaux non interceptables","text":"<ol> <li>Tester SIGKILL et SIGSTOP </li> <li>Envoyez le signal <code>SIGKILL</code> : <pre><code>kill -9 &lt;PID&gt;\n</code></pre></li> <li>Relancez le programme, puis envoyez <code>SIGSTOP</code> : <pre><code>kill -STOP &lt;PID&gt;\n</code></pre></li> </ol> <p>#### Explications :    - <code>SIGKILL</code> : Termine imm\u00e9diatement le processus, sans possibilit\u00e9 d\u2019interception.    - <code>SIGSTOP</code> : Met un processus en pause, \u00e9galement sans possibilit\u00e9 d\u2019interception.  </p> <p>Question : Pourquoi ces signaux (SIGKILL, SIGSTOP) ne peuvent-ils pas \u00eatre intercept\u00e9s ? </p> <p>Indice : Ces signaux sont g\u00e9r\u00e9s directement par le noyau Linux pour garantir qu\u2019ils soient appliqu\u00e9s sans possibilit\u00e9 de modification par le processus. R\u00e9fl\u00e9chissez \u00e0 des situations o\u00f9 il serait dangereux de laisser un programme ignorer ces signaux.  </p>"},{"location":"activites/signaux/#etape-4-experimenter-avec-les-signaux-utilisateur","title":"\u00c9tape 4 : Exp\u00e9rimenter avec les signaux utilisateur","text":"<ol> <li>Dans le terminal droit, envoyez plusieurs fois <code>SIGUSR1</code> et <code>SIGUSR2</code>.  </li> <li>Observez les r\u00e9sultats.  </li> </ol> <p>Question : Quels sont les cas d\u2019utilisation concrets pour ces signaux ? </p> <p>Indice : Dans le programme interactif, voyez comment <code>SIGUSR1</code> g\u00e9n\u00e8re un nombre al\u00e9atoire ou comment <code>SIGUSR2</code> affiche une citation. Imaginez comment ces signaux pourraient \u00eatre utilis\u00e9s dans un programme r\u00e9el.  </p>"},{"location":"activites/signaux/#3-tableau-recapitulatif-des-signaux","title":"3. Tableau r\u00e9capitulatif des signaux","text":"Signal Nom pour <code>kill</code> Num\u00e9ro Explication Cas d\u2019utilisation SIGINT <code>-INT</code> 2 Interrompt un processus en premier plan. Arr\u00eater un processus via <code>CTRL+C</code>. SIGTERM <code>-TERM</code> 15 Demande \u00e0 un processus de s\u2019arr\u00eater proprement. Fermer un programme en cours d\u2019ex\u00e9cution. SIGKILL <code>-KILL</code> 9 Force l\u2019arr\u00eat imm\u00e9diat d\u2019un processus (non interceptable). Terminer un programme bloqu\u00e9. SIGSTOP <code>-STOP</code> (non assign\u00e9) Met un processus en pause (non interceptable). Suspendre temporairement un processus. SIGUSR1 <code>-USR1</code> 10 Signal utilisateur 1 (d\u00e9fini par le programme). Personnalisation : ici, g\u00e9n\u00e8re un nombre al\u00e9atoire. SIGUSR2 <code>-USR2</code> 12 Signal utilisateur 2 (d\u00e9fini par le programme). Personnalisation : ici, affiche une citation humoristique. SIGQUIT <code>-QUIT</code> 3 Interrompt un processus avec vidage m\u00e9moire. Arr\u00eater un programme avec diagnostic."},{"location":"activites/signaux/#4-resume-des-points-cles","title":"4. R\u00e9sum\u00e9 des points cl\u00e9s","text":"<ul> <li>Les signaux permettent de communiquer avec les processus pour les interrompre, les suspendre ou leur demander une t\u00e2che.  </li> <li>Les signaux peuvent \u00eatre envoy\u00e9s via le clavier (<code>CTRL+C</code>, <code>CTRL+Z</code>) ou la commande <code>kill</code>.  </li> <li>Certains signaux, comme <code>SIGKILL</code> et <code>SIGSTOP</code>, ne peuvent pas \u00eatre intercept\u00e9s par les programmes.  </li> <li>Les signaux utilisateurs (<code>SIGUSR1</code>, <code>SIGUSR2</code>) permettent de d\u00e9finir des actions personnalis\u00e9es.</li> </ul>"},{"location":"activites/signaux/#5-evaluation-des-connaissances","title":"5. \u00c9valuation des connaissances","text":""},{"location":"activites/signaux/#questions-a-choix-multiples","title":"Questions \u00e0 choix multiples","text":"<p>Q1 : Quels signaux ne peuvent pas \u00eatre intercept\u00e9s par un programme ? 1. SIGTERM 2. SIGKILL 3. SIGUSR1 4. SIGSTOP  </p> <p>Indice : Ces signaux ne laissent aucune chance au processus de r\u00e9agir et sont toujours appliqu\u00e9s imm\u00e9diatement.  </p> <p>R\u00e9ponses attendues : 2 et 4.  </p> <p>Q2 : Que fait <code>SIGINT</code> lorsqu\u2019il est envoy\u00e9 \u00e0 un processus ? 1. Met le processus en pause. 2. Force l\u2019arr\u00eat imm\u00e9diat du processus. 3. Demande une interruption propre. 4. Interrompt le processus avec possibilit\u00e9 de gestion.  </p> <p>Indice : C\u2019est le signal que vous envoyez en appuyant sur <code>CTRL+C</code>. Que se passe-t-il dans le programme interactif ?  </p> <p>R\u00e9ponse attendue : 4.  </p> <p>Q3 : Pourquoi <code>SIGUSR1</code> et <code>SIGUSR2</code> sont-ils utiles ? 1. Ils permettent de d\u00e9finir des actions personnalis\u00e9es. 2. Ils sont indispensables au fonctionnement du syst\u00e8me. 3. Ils forcent un processus \u00e0 red\u00e9marrer.  </p> <p>Indice : Regardez ce que fait le programme quand vous envoyez ces signaux : le comportement est d\u00e9fini par le programme lui-m\u00eame.  </p> <p>R\u00e9ponse attendue : 1.  </p>"},{"location":"activites/signaux/#ces-indices-sont-concus-pour-guider-les-etudiants-tout-en-les-encourageant-a-relier-les-questions-a-leurs-experimentations-pratiques","title":"Ces indices sont con\u00e7us pour guider les \u00e9tudiants tout en les encourageant \u00e0 relier les questions \u00e0 leurs exp\u00e9rimentations pratiques.","text":""},{"location":"activites/signaux/#6-lien-avec-les-notions-futures","title":"6. Lien avec les notions futures","text":"<ul> <li>Processus zombies : Les signaux comme <code>SIGKILL</code> peuvent provoquer des zombies si le parent ne r\u00e9cup\u00e8re pas l\u2019\u00e9tat du processus enfant.  </li> <li>Processus orphelins : L\u2019envoi de signaux peut \u00e9galement \u00eatre utilis\u00e9 pour manipuler les processus parent/enfant.  </li> <li>Scripts d\u2019administration syst\u00e8me : Automatiser l\u2019envoi et la gestion des signaux dans des scripts bash.</li> </ul>"},{"location":"activites/terminal/","title":"Sc\u00e9nario : Terminal et processus","text":"<p>Dans ce premier sc\u00e9nario, nous allons explorer la relation entre les terminaux et les processus sous Linux. Vous d\u00e9couvrirez comment les processus sont li\u00e9s \u00e0 leur terminal de contr\u00f4le et comment observer ces relations.</p>"},{"location":"activites/terminal/#objectifs-dapprentissage","title":"Objectifs d'apprentissage","text":"<p>\u00c0 la fin de ce sc\u00e9nario, vous serez capable de :</p> <ul> <li>Identifier le terminal associ\u00e9 \u00e0 un processus</li> <li>Comprendre la notion de terminal de contr\u00f4le</li> <li>Ma\u00eetriser les options de base de la commande <code>ps</code></li> </ul>"},{"location":"activites/terminal/#concepts-fondamentaux","title":"Concepts fondamentaux","text":""},{"location":"activites/terminal/#quest-ce-quun-processus","title":"Qu'est-ce qu'un processus ?","text":"<p>Un processus (process) est un programme en cours d'ex\u00e9cution. Mais cette d\u00e9finition technique ne suffit pas \u00e0 comprendre ce concept essentiel. Prenons une premi\u00e8re analogie simple pour commencer :</p> <p>Dans un restaurant, chaque table occup\u00e9e repr\u00e9sente un processus diff\u00e9rent :</p> <ul> <li>La table a son propre espace (la m\u00e9moire allou\u00e9e au processus)</li> <li>Les clients ont leur propre commande (les instructions du programme)</li> <li>Chaque table a un num\u00e9ro unique (comme le PID - Process IDentifier)</li> </ul> <p>Une analogie qui va s'enrichir</p> <p>Cette image du restaurant va s'enrichir au fil des sc\u00e9narios. Nous verrons comment l'organisation compl\u00e8te d'un restaurant (serveurs, ma\u00eetre d'h\u00f4tel, chef de salle...) nous aide \u00e0 comprendre la gestion des processus dans son ensemble. Si vous \u00eates curieux, vous pouvez d\u00e9j\u00e0 consulter l'analogie compl\u00e8te du restaurant, mais ne vous inqui\u00e9tez pas si certains concepts ne sont pas encore clairs - nous les d\u00e9couvrirons progressivement.</p> <p>En informatique, lorsque vous lancez un programme comme <code>firefox</code> ou notre <code>proclab</code>, le syst\u00e8me d'exploitation :</p> <ol> <li>Cr\u00e9e un nouvel espace en m\u00e9moire</li> <li>Attribue un num\u00e9ro unique (PID) au processus</li> <li>Charge le programme dans cet espace</li> <li>Commence son ex\u00e9cution</li> </ol> <p>Exemple concret</p> <p>Quand vous lancez trois fois <code>proclab</code>, vous cr\u00e9ez trois processus distincts :</p> <ul> <li>Chacun a son propre PID</li> <li>Chacun s'ex\u00e9cute ind\u00e9pendamment</li> <li>Chacun a sa propre zone m\u00e9moire</li> </ul> <pre><code>graph TD\n    A[Programme proclab] --&gt;|Lancement 1| B[Processus PID 1234]\n    A --&gt;|Lancement 2| C[Processus PID 1235]\n    A --&gt;|Lancement 3| D[Processus PID 1236]</code></pre>"},{"location":"activites/terminal/#le-terminal-de-controle","title":"Le terminal de contr\u00f4le","text":"<p>Un terminal de contr\u00f4le (controlling terminal) est l'interface par laquelle un utilisateur interagit avec un processus. Sous Linux, chaque processus est g\u00e9n\u00e9ralement associ\u00e9 \u00e0 un terminal qui lui permet de :</p> <ul> <li>Recevoir les entr\u00e9es de l'utilisateur (clavier)</li> <li>Afficher ses sorties (\u00e9cran)</li> <li>Recevoir des signaux de contr\u00f4le (comme Ctrl+C)</li> </ul> <p>Les terminaux physiques et virtuels</p> <p>Historiquement, un terminal \u00e9tait un appareil physique (comme un t\u00e9letype). Aujourd'hui, nous utilisons des terminaux virtuels (virtual terminals) ou des \u00e9mulateurs de terminal (terminal emulators) qui simulent le comportement des terminaux physiques.</p>"},{"location":"activites/terminal/#mise-en-pratique","title":"Mise en pratique","text":""},{"location":"activites/terminal/#preparation-de-lenvironnement","title":"Pr\u00e9paration de l'environnement","text":"<ol> <li>Lancez Terminator et divisez la fen\u00eatre en deux parties verticales (Ctrl+Shift+E)</li> <li>Dans chaque partie, vous aurez un terminal distinct avec son propre identifiant</li> </ol>"},{"location":"activites/terminal/#etape-1-identifier-son-terminal","title":"\u00c9tape 1 : Identifier son terminal","text":"<p>Dans chaque terminal, ex\u00e9cutez la commande :</p> <pre><code>tty\n</code></pre> <p>Cette commande affiche le chemin du p\u00e9riph\u00e9rique terminal. Vous obtiendrez quelque chose comme <code>/dev/pts/0</code> pour le premier terminal et <code>/dev/pts/1</code> pour le second.</p> <p>Comprendre la sortie</p> <p>Le pr\u00e9fixe <code>/dev/pts/</code> indique qu'il s'agit d'un pseudo-terminal (pseudo-terminal slave), une \u00e9mulation logicielle d'un terminal physique.</p>"},{"location":"activites/terminal/#etape-2-observer-les-processus","title":"\u00c9tape 2 : Observer les processus","text":"<p>Ouvrons d'abord le premier terminal. Nous allons lancer <code>proclab</code> en arri\u00e8re-plan en utilisant le symbole <code>&amp;</code> :</p> <pre><code>proclab &amp;\n</code></pre> <p>Quand nous ajoutons <code>&amp;</code> \u00e0 la fin d'une commande, nous demandons au shell de lancer le programme sans bloquer notre terminal. Normalement, quand vous lancez un programme comme <code>proclab</code>, votre terminal est monopolis\u00e9 jusqu'\u00e0 ce que le programme se termine \u2014 vous ne pouvez plus taper de commandes. Avec <code>&amp;</code>, le terminal reste disponible : vous retrouvez imm\u00e9diatement l'invite de commande et pouvez continuer \u00e0 l'utiliser pendant que proclab s'ex\u00e9cute en parall\u00e8le.</p> <p>Maintenant, v\u00e9rifions quels processus sont visibles dans ce terminal :</p> <pre><code>ps\n</code></pre> <p>Vous devriez voir une sortie similaire \u00e0 celle-ci :</p> <pre><code>$ ps\n    PID TTY          TIME CMD\n   2019 pts/0    00:00:00 bash\n   7180 pts/0    00:00:33 proclab\n   8099 pts/0    00:00:00 ps\n</code></pre> <p>Cette commande nous montre trois processus :</p> <ul> <li>bash : le shell qui contr\u00f4le notre terminal</li> <li>proclab : notre programme qui s'ex\u00e9cute en arri\u00e8re-plan</li> <li>ps : la commande que nous venons de lancer</li> </ul>"},{"location":"activites/terminal/#etape-3-voir-les-processus-des-autres-terminaux","title":"\u00c9tape 3 : Voir les processus des autres terminaux","text":"<p>Passons maintenant au second terminal et ex\u00e9cutons la m\u00eame commande :</p> <pre><code>ps\n</code></pre> <p>Cette fois, la sortie est diff\u00e9rente :</p> <pre><code>$ ps\n    PID TTY          TIME CMD\n   6584 pts/1    00:00:00 bash\n   8035 pts/1    00:00:00 ps\n</code></pre> <p>Nous ne voyons plus proclab ! C'est normal : par d\u00e9faut, <code>ps</code> ne montre que les processus du terminal courant. Pour voir les processus de tous les terminaux, nous pouvons utiliser l'option <code>-a</code> :</p> <p>Observation importante</p> <p>Cette exp\u00e9rience nous montre que : - Chaque terminal ne voit que ses propres processus. Vous ne verrez pas les processus du premier terminal dans le second, et vice versa. - La colonne TTY nous indique le terminal de contr\u00f4le de chaque processus - Un processus reste attach\u00e9 \u00e0 son terminal m\u00eame en arri\u00e8re-plan</p> <p>Dans le second terminal, ex\u00e9cutez :</p> <pre><code>ps -a\n</code></pre> <p>Cette fois, nous obtenons :</p> <pre><code>    PID TTY          TIME CMD\n   7180 pts/0    00:11:09 proclab\n   8730 pts/1    00:00:00 ps\n</code></pre> <p>O\u00f9 est pass\u00e9 bash ?</p> <p>Vous remarquez que bash n'appara\u00eet plus dans cette liste ? L'option <code>-a</code> montre les processus de tous les terminaux, mais exclut volontairement les processus \u00ab\u202fmeneurs de session\u202f\u00bb comme bash. Ces processus sp\u00e9ciaux g\u00e8rent chaque terminal et sont toujours pr\u00e9sents, c'est pourquoi ps les filtre par d\u00e9faut pour plus de clart\u00e9.</p>"},{"location":"activites/terminal/#visualisation-de-la-relation-terminal-processus","title":"Visualisation de la relation terminal-processus","text":"<pre><code>graph TD\n    A[Terminal pts/0] --&gt; F[shell] --&gt; B[proclab]\n    C[Terminal pts/1] --&gt; D[shell] --&gt; E[ps]\n    style A fill:#f9f,stroke:#333\n    style C fill:#f9f,stroke:#333</code></pre>"},{"location":"activites/terminal/#exercices-pratiques","title":"Exercices pratiques","text":""},{"location":"activites/terminal/#exercice-1-explorer-les-options-de-ps","title":"Exercice 1 : Explorer les options de ps","text":"<p>Pour comprendre progressivement les options de <code>ps</code>, nous allons les explorer une par une :</p> <ol> <li> <p>Commencez par la commande de base :</p> <pre><code>ps\n</code></pre> <p>Observez : - Combien de processus sont list\u00e9s ? - \u00c0 quoi correspondent-ils ?</p> <p>Indice : Cette commande montre uniquement les processus li\u00e9s \u00e0 votre terminal actuel.</p> </li> <li> <p>Ajoutez l'option <code>-a</code> :</p> <pre><code>ps -a\n</code></pre> <p>Observez : - Quels processus suppl\u00e9mentaires apparaissent ? - Pourquoi ne voyez-vous pas votre shell (bash) ?</p> <p>Indice : <code>-a</code> montre les processus de tous les terminaux, sauf les \"leaders de session\".</p> </li> <li> <p>Utilisez l'option <code>-f</code> (format complet) :</p> <pre><code>ps -f\n</code></pre> <p>Analysez les nouvelles colonnes :</p> <ul> <li>UID : Qui a lanc\u00e9 le processus ?</li> <li>PPID : Quel est le processus parent ?</li> <li>TIME : Depuis combien de temps le processus tourne ?</li> </ul> </li> </ol> <p>Question : Pourquoi le PPID est-il utile \u00e0 conna\u00eetre ?</p> <ol> <li> <p>Enfin, essayez <code>-e</code> pour voir tous les processus :</p> <pre><code>ps -e | grep -E \"proclab|bash|terminal\"\n</code></pre> <p>Note : Nous filtrons la sortie avec <code>grep</code> pour nous concentrer sur les processus pertinents.</p> <p>Observez :</p> <ul> <li>Combien y a-t-il d'instances de bash ?</li> <li>Pouvez-vous identifier \u00e0 quel terminal chacune correspond ?</li> </ul> </li> </ol> <p>Pour r\u00e9fl\u00e9chir :</p> <ul> <li>Quelle option de <code>ps</code> utiliseriez-vous pour :<ul> <li>Voir uniquement vos processus ?</li> <li>Identifier le parent d'un processus sp\u00e9cifique ?</li> <li>Trouver tous les terminaux actifs ?</li> </ul> </li> </ul> <p>Conseil pratique : Pour \u00e9viter d'\u00eatre submerg\u00e9 par la sortie de <code>ps -e</code>, vous pouvez toujours utiliser <code>grep</code> pour filtrer les r\u00e9sultats :</p> <pre><code>ps -e | grep nom_du_programme\n</code></pre>"},{"location":"activites/terminal/#exercice-2-manipuler-les-processus","title":"Exercice 2 : Manipuler les processus","text":"<ol> <li> <p>Dans le Terminal A :</p> <ul> <li>Lancez trois instances de proclab en arri\u00e8re-plan</li> <li>Utilisez <code>ps</code> pour les identifier</li> <li>Notez les diff\u00e9rents PID</li> </ul> </li> <li> <p>Dans le Terminal B :</p> <ul> <li>Utilisez <code>ps -a</code> pour voir tous les processus</li> <li>Comparez avec la sortie du Terminal A</li> </ul> </li> </ol> <p>Questions d'analyse</p> <ol> <li>Pourquoi les PID sont-ils diff\u00e9rents pour chaque instance ?</li> <li>Comment le syst\u00e8me fait-il pour g\u00e9rer plusieurs processus simultan\u00e9ment ?</li> <li>Quel est le r\u00f4le du processus bash dans chaque terminal ?</li> </ol>"},{"location":"activites/terminal/#points-cles-a-retenir","title":"Points cl\u00e9s \u00e0 retenir","text":"<ul> <li>Chaque processus a un identifiant unique (PID) et est associ\u00e9 \u00e0 un terminal</li> <li>Chaque terminal a un identifiant unique (<code>/dev/pts/X</code>)</li> <li>Les terminaux permettent l'interaction entre l'utilisateur et les processus</li> <li>La commande <code>ps</code> est essentielle pour observer et comprendre les processus</li> <li>Un terminal peut g\u00e9rer plusieurs processus simultan\u00e9ment</li> <li>Les processus en arri\u00e8re-plan lib\u00e8rent le terminal tout en continuant \u00e0 s'ex\u00e9cuter</li> </ul>"},{"location":"activites/terminal/#evaluation-des-connaissances","title":"\u00c9valuation des connaissances","text":"<p>Quiz de compr\u00e9hension</p> <ol> <li>Qu'est-ce qui identifie de mani\u00e8re unique un processus sous Linux ?</li> <li>Quel est le r\u00f4le du terminal de contr\u00f4le ?</li> <li>Comment peut-on lancer un processus en arri\u00e8re-plan ?</li> <li>Quelle commande permet de voir tous les processus du syst\u00e8me ?</li> <li>Pourquoi est-il important que chaque processus ait son propre espace m\u00e9moire ?</li> </ol>"},{"location":"activites/terminal/#lien-avec-les-notions-futures","title":"Lien avec les notions futures","text":"<p>Dans les prochains sc\u00e9narios, nous explorerons :</p> <ul> <li>La gestion des processus en premier plan et en arri\u00e8re-plan</li> <li>Les signaux que le terminal peut envoyer aux processus</li> <li>Les \u00e9tats des processus et leur cycle de vie</li> <li>Les processus zombies et orphelins</li> </ul> <p>Pr\u00e9paration pour la suite</p> <p>Pour le prochain sc\u00e9nario sur la gestion foreground/background, r\u00e9fl\u00e9chissez \u00e0 :</p> <ul> <li>Comment le syst\u00e8me g\u00e8re plusieurs processus simultan\u00e9ment</li> <li>Comment un utilisateur peut interagir avec des processus en cours d'ex\u00e9cution</li> <li>Pourquoi on pourrait vouloir mettre un processus en arri\u00e8re-plan</li> </ul>"},{"location":"activites/zombie/","title":"Sc\u00e9nario : Processus zombies","text":""},{"location":"activites/zombie/#objectif-pedagogique","title":"Objectif p\u00e9dagogique","text":"<p>Apprendre \u00e0 identifier, comprendre et manipuler un processus zombie (zombie process) sous Linux par l\u2019exp\u00e9rimentation. Cette activit\u00e9 permet \u00e9galement de d\u00e9couvrir et d'utiliser des commandes essentielles pour la gestion des processus sous Linux.</p>"},{"location":"activites/zombie/#1-introduction-quest-ce-quun-processus-zombie","title":"1. Introduction : Qu\u2019est-ce qu\u2019un processus zombie ?","text":""},{"location":"activites/zombie/#definition","title":"D\u00e9finition","text":"<p>Un processus zombie (zombie process), parfois appel\u00e9 processus mort-vivant, est un processus termin\u00e9 dont l'entr\u00e9e dans la table des processus n'a pas \u00e9t\u00e9 supprim\u00e9e parce que son processus parent n'a pas encore r\u00e9cup\u00e9r\u00e9 son \u00e9tat de sortie avec la commande syst\u00e8me <code>wait()</code>.</p>"},{"location":"activites/zombie/#concept-cle","title":"Concept cl\u00e9","text":"<ul> <li>Lorsque le processus enfant se termine, il transmet son \u00e9tat au parent via une structure appel\u00e9e \u00ab entr\u00e9e dans la table des processus \u00bb.  </li> <li>Si le parent ne r\u00e9cup\u00e8re pas cet \u00e9tat avec <code>wait()</code>, l'entr\u00e9e reste active et devient un zombie.</li> </ul>"},{"location":"activites/zombie/#exemple-concret","title":"Exemple concret","text":"<p>Imaginez un programme (parent) qui lance un calcul (enfant). Si le parent ne \u00ab nettoie \u00bb pas le r\u00e9sultat du calcul, le syst\u00e8me conserve une trace inutile du processus enfant, ce qui encombre la table des processus.</p>"},{"location":"activites/zombie/#2-experimentation-guidee","title":"2. Exp\u00e9rimentation guid\u00e9e","text":""},{"location":"activites/zombie/#preparation","title":"Pr\u00e9paration","text":"<ol> <li> <p>Ouvrir Terminator     Divisez votre terminal en deux colonnes (cliquez droit \u2192 \u00ab Split vertically \u00bb) pour avoir une fen\u00eatre gauche et une fen\u00eatre droite.</p> </li> <li> <p>Lancer le programme     Dans le terminal gauche, ex\u00e9cutez le programme qui simule des processus zombies :  </p> <pre><code>proczombi\n</code></pre> <p>Laissez ce terminal actif pour interagir avec le menu.</p> </li> </ol>"},{"location":"activites/zombie/#etape-1-identifier-un-processus-zombie","title":"\u00c9tape 1 : Identifier un processus zombie","text":"<ol> <li> <p>Dans le terminal droit, affichez la liste des processus en cours d\u2019ex\u00e9cution \u00e0 l\u2019aide de la commande <code>ps</code> :  </p> <pre><code>ps -ef | grep proczombi\n</code></pre> <p>Explications : - <code>ps</code> : Commande qui affiche une liste des processus actifs. - <code>-e</code> : Montre tous les processus en cours sur le syst\u00e8me. - <code>-f</code> : Affiche des informations d\u00e9taill\u00e9es, comme les PID, les PPID et les noms des processus. - <code>grep proczombi</code> : Filtre les r\u00e9sultats pour ne montrer que ceux contenant le mot \u00ab proczombi \u00bb.</p> </li> </ol> <p>Indice : Rep\u00e9rez les PID (identifiants) des processus parent et enfant.</p> <ol> <li> <p>Revenez au terminal gauche, utilisez le menu du programme pour obtenir des informations suppl\u00e9mentaires sur les processus parent et enfant. Notez les PID pour la suite.</p> </li> <li> <p>Revenez au terminal droit. Tuez le processus enfant :  </p> <pre><code>kill -9 &lt;PID_enfant&gt;\n</code></pre> <p>Explications : - <code>kill</code> : Envoie un signal \u00e0 un processus pour le contr\u00f4ler (exemple : le terminer). - <code>-9</code> : Signal SIGKILL, qui force la terminaison imm\u00e9diate du processus. - <code>&lt;PID_enfant&gt;</code> : Remplacez <code>&lt;PID_enfant&gt;</code> par l\u2019identifiant du processus enfant.</p> </li> <li> <p>V\u00e9rifiez son \u00e9tat avec la commande suivante :  </p> <pre><code>ps -l\n</code></pre> <p>Explications : - <code>-l</code> : Mode long qui affiche des informations suppl\u00e9mentaires, comme le statut (state) du processus. - Regardez la colonne <code>STAT</code>.  </p> <p>Indice : Un zombie est signal\u00e9 par un <code>Z</code> dans la colonne <code>STAT</code>.</p> </li> </ol>"},{"location":"activites/zombie/#question-dobservation","title":"Question d\u2019observation","text":"<ul> <li>Que remarquez-vous dans la colonne <code>STAT</code> pour l\u2019enfant apr\u00e8s l\u2019avoir tu\u00e9 ? (Indice : Le processus est toujours visible, mais il est marqu\u00e9 comme un zombie.) </li> </ul>"},{"location":"activites/zombie/#etape-2-nettoyer-un-zombie","title":"\u00c9tape 2 : Nettoyer un zombie","text":"<ol> <li>Revenez dans le terminal gauche. Utilisez l\u2019option du menu permettant d\u2019ex\u00e9cuter la commande <code>wait()</code>.  </li> <li> <p>Revenez au terminal droit et v\u00e9rifiez que le zombie a disparu :  </p> <pre><code>ps -l\n</code></pre> </li> </ol>"},{"location":"activites/zombie/#question-danalyse","title":"Question d\u2019analyse","text":"<ul> <li>Pourquoi l\u2019utilisation de <code>wait()</code> a-t-elle supprim\u00e9 le zombie ? (Indice : <code>wait()</code> permet au parent de r\u00e9cup\u00e9rer l\u2019\u00e9tat du processus enfant, ce qui nettoie son entr\u00e9e dans la table des processus.)</li> </ul>"},{"location":"activites/zombie/#3-exercices-pratiques","title":"3. Exercices pratiques","text":""},{"location":"activites/zombie/#exercice-1-comprendre-la-commande-ps","title":"Exercice 1 : Comprendre la commande <code>ps</code>","text":"<p>Dans le terminal droit, ex\u00e9cutez les commandes suivantes et comparez leurs r\u00e9sultats :  </p> <ol> <li> <p>Liste compl\u00e8te des processus avec <code>ps</code> :  </p> <pre><code>ps -e\n</code></pre> </li> <li> <p>Affichage d\u00e9taill\u00e9 :  </p> <pre><code>ps -ef\n</code></pre> </li> <li> <p>Affichage en mode long :  </p> <pre><code>ps -l\n</code></pre> </li> </ol>"},{"location":"activites/zombie/#questions","title":"Questions","text":"<ul> <li>Quelle commande montre les relations entre les processus (PID et PPID) ?  </li> <li>Quelle commande affiche le statut (<code>STAT</code>) des processus ?  </li> </ul>"},{"location":"activites/zombie/#exercice-2-experimenter-avec-plusieurs-zombies","title":"Exercice 2 : Exp\u00e9rimenter avec plusieurs zombies","text":"<ol> <li>Relancez <code>proczombi</code>.  </li> <li>Modifiez le menu pour cr\u00e9er plusieurs enfants.  </li> <li>Tuez un ou plusieurs enfants et observez leurs \u00e9tats.  </li> </ol>"},{"location":"activites/zombie/#questions_1","title":"Questions","text":"<ul> <li>Que se passe-t-il si le parent n\u2019appelle pas <code>wait()</code> imm\u00e9diatement ?  </li> <li>Comment v\u00e9rifier l\u2019\u00e9tat des processus zombies ?  </li> </ul>"},{"location":"activites/zombie/#exercice-3-reflexion-critique","title":"Exercice 3 : R\u00e9flexion critique","text":"<ol> <li>Expliquez en une phrase pourquoi les zombies consomment peu de ressources mais doivent \u00eatre \u00e9vit\u00e9s.  </li> <li>Quels probl\u00e8mes pourraient survenir si un programme g\u00e9n\u00e8re de nombreux zombies ?  </li> </ol>"},{"location":"activites/zombie/#4-resume-des-points-cles","title":"4. R\u00e9sum\u00e9 des points cl\u00e9s","text":"<ul> <li>Un processus zombie se produit lorsqu\u2019un enfant termine son ex\u00e9cution, mais que son parent n\u2019a pas r\u00e9cup\u00e9r\u00e9 son \u00e9tat avec <code>wait()</code>.  </li> <li>Un zombie est identifiable gr\u00e2ce \u00e0 la colonne <code>STAT</code> avec la valeur <code>Z</code>.  </li> <li>Les zombies consomment peu de ressources, mais encombrent la table des processus, ce qui peut nuire \u00e0 la stabilit\u00e9 du syst\u00e8me si leur nombre devient \u00e9lev\u00e9.  </li> <li>Utilisez <code>wait()</code> dans le parent pour r\u00e9cup\u00e9rer l\u2019\u00e9tat d\u2019un enfant et supprimer les zombies.</li> </ul>"},{"location":"activites/zombie/#5-evaluation-des-connaissances","title":"5. \u00c9valuation des connaissances","text":""},{"location":"activites/zombie/#questions-a-choix-multiples","title":"Questions \u00e0 choix multiples","text":"<p>Q1 : Qu\u2019est-ce qui fait qu\u2019un processus devient un zombie ? </p> <ol> <li>Il tourne ind\u00e9finiment.  </li> <li>Il est mort, mais son parent n\u2019a pas r\u00e9cup\u00e9r\u00e9 son \u00e9tat.  </li> <li>Il n\u2019a jamais \u00e9t\u00e9 lanc\u00e9 correctement.  </li> </ol> <p>R\u00e9ponse attendue : 2.  </p> <p>Q2 : Quels outils permettent d\u2019observer les processus zombies sous Linux ? </p> <ol> <li><code>htop</code> </li> <li><code>ps</code> </li> <li><code>wait</code> </li> <li><code>kill</code> </li> </ol> <p>R\u00e9ponses attendues : 1 et 2.  </p> <p>Q3 : Que se passe-t-il si un parent meurt avant d\u2019appeler <code>wait()</code> sur ses enfants ? </p> <ol> <li>Les enfants deviennent orphelins.  </li> <li>Les enfants deviennent zombies.  </li> <li><code>init</code> ou <code>systemd</code> adoptent les enfants.  </li> </ol> <p>R\u00e9ponse attendue : 1 et 3.</p>"},{"location":"activites/zombie/#6-lien-avec-les-notions-futures","title":"6. Lien avec les notions futures","text":"<ul> <li>Processus orphelins : Dans une prochaine activit\u00e9, vous apprendrez ce qu\u2019il advient des processus lorsqu\u2019un parent meurt avant eux.  </li> <li>Gestion des ressources syst\u00e8me : Comment les syst\u00e8mes d\u2019exploitation g\u00e8rent efficacement des milliers de processus actifs.  </li> </ul>"},{"location":"activites/zombie/#notes-pedagogiques","title":"Notes p\u00e9dagogiques","text":"<p>Cette activit\u00e9 guide les \u00e9tudiants dans la d\u00e9couverte des processus zombies tout en leur permettant de se familiariser avec des commandes essentielles comme <code>ps</code>, <code>kill</code> et <code>wait()</code>. Les questions et indices encouragent une r\u00e9flexion active. Vous pouvez enrichir l\u2019activit\u00e9 avec des sch\u00e9mas pour visualiser les relations entre parent, enfant et syst\u00e8me.  </p>"},{"location":"ressources/alias/","title":"Les alias pratiques pour la gestion des processus","text":""},{"location":"ressources/alias/#introduction","title":"Introduction","text":"<p>Les alias (shell aliases) sont des raccourcis de commande essentiels pour gagner en efficacit\u00e9 lors de l'analyse et la gestion des processus sous Linux. Ce document vous explique comment configurer et utiliser les alias n\u00e9cessaires aux activit\u00e9s pratiques sur les processus.</p>"},{"location":"ressources/alias/#configuration-des-alias","title":"Configuration des alias","text":""},{"location":"ressources/alias/#emplacement-des-alias","title":"Emplacement des alias","text":"<p>Sous Linux, les alias permanents sont g\u00e9n\u00e9ralement stock\u00e9s dans le fichier <code>~/.bash_aliases</code>. Ce fichier est automatiquement charg\u00e9 par votre shell gr\u00e2ce \u00e0 ces lignes pr\u00e9sentes dans votre <code>~/.bashrc</code> :</p> <pre><code>if [ -f ~/.bash_aliases ]; then\n    . ~/.bash_aliases\nfi\n</code></pre>"},{"location":"ressources/alias/#alias-essentiels-pour-la-gestion-des-processus","title":"Alias essentiels pour la gestion des processus","text":"<p>Voici les alias que nous utiliserons dans nos activit\u00e9s. Ajoutez-les \u00e0 votre fichier <code>~/.bash_aliases</code> :</p> <pre><code># Affiche les processus avec les colonnes essentielles pour une analyse rapide :\n#   - PPID : PID du processus parent.\n#   - PID  : Identifiant du processus.\n#   - STAT : \u00c9tat du processus (Running, Sleeping, etc.).\n#   - TTY  : Terminal associ\u00e9 au processus (ou ? si aucun).\n#   - USER : Utilisateur propri\u00e9taire du processus.\n#   - CMD  : Commande utilis\u00e9e pour d\u00e9marrer le processus.\nalias psess='ps -o ppid,pid,stat,tty,user,cmd'\n\n# Affiche l'arborescence compl\u00e8te des processus \u00e0 partir du shell courant.\n# Options :\n#   -p : Affiche les PIDs (identifiants des processus).\n#   -c : D\u00e9sactive le regroupement des processus similaires.\n#   -l : \u00c9vite la troncature des lignes longues.\nalias treeproc='pstree -p -c -l $$'\n\n# Contraction de \"Shell Tree\", indiquant l'arborescence des processus autour du shell.\nalias stree='pstree -p -c -l $$'\n\n# Affiche tous les processus enfants de terminator\nalias termtree='pstree -p -c -l $(ps -o ppid= -p $$)'\n</code></pre>"},{"location":"ressources/alias/#activation-des-alias","title":"Activation des alias","text":"<p>Apr\u00e8s avoir ajout\u00e9 ces alias, vous devez les activer avec la commande :</p> <pre><code>source ~/.bashrc\n</code></pre>"},{"location":"ressources/alias/#utilisation-des-alias","title":"Utilisation des alias","text":""},{"location":"ressources/alias/#psess-affichage-essentiel-des-processus","title":"psess : Affichage essentiel des processus","text":"<p>L'alias <code>psess</code> remplace la commande <code>ps</code> avec des options optimis\u00e9es pour l'analyse des processus :</p> <pre><code>$ psess\n  PPID   PID STAT TTY      USER     CMD\n  1234  5678 S    pts/0    student  bash\n  5678  5679 R    pts/0    student  procarbo\n</code></pre>"},{"location":"ressources/alias/#treeproc-visualisation-de-larborescence","title":"treeproc : Visualisation de l'arborescence","text":"<pre><code>$ treeproc\nbash(12345)\u2500\u252c\u2500procarbo(12346)\u2500\u2500\u2500procarbo(12347)\n            \u2514\u2500pstree(12348)\n</code></pre> <p>La commande affiche une arborescence claire des processus avec leurs PID.</p>"},{"location":"ressources/alias/#stree-et-termtree-analyse-contextuelle","title":"stree et termtree : Analyse contextuelle","text":"<p>Ces alias permettent d'observer les processus dans leur contexte : - <code>stree</code> : Focus sur les processus li\u00e9s au shell actuel - <code>termtree</code> : Vue des processus attach\u00e9s \u00e0 votre terminal</p>"},{"location":"ressources/alias/#bonnes-pratiques","title":"Bonnes pratiques","text":"<ol> <li>Documentation des alias</li> <li>Commentez chaque alias avec sa fonction et ses options</li> <li> <p>Groupez les alias par cat\u00e9gorie</p> </li> <li> <p>Maintenance</p> </li> <li>Sauvegardez r\u00e9guli\u00e8rement votre fichier <code>~/.bash_aliases</code></li> <li> <p>Supprimez les alias que vous n'utilisez plus</p> </li> <li> <p>Partage et r\u00e9utilisation</p> </li> <li>Partagez vos alias utiles avec vos coll\u00e8gues</li> <li>Cr\u00e9ez un d\u00e9p\u00f4t Git pour vos dotfiles</li> </ol>"},{"location":"ressources/alias/#points-dattention","title":"Points d'attention","text":"<ul> <li>Un alias mal configur\u00e9 peut masquer une commande syst\u00e8me</li> <li>Les alias ne sont pas disponibles dans les scripts shell</li> <li>Les alias sont sp\u00e9cifiques \u00e0 votre shell (bash dans notre cas)</li> </ul>"},{"location":"ressources/alias/#exercices-pratiques","title":"Exercices pratiques","text":"<ol> <li> <p>Cr\u00e9ez un alias <code>pstop</code> qui affiche les 5 processus consommant le plus de CPU : <pre><code>alias pstop='ps aux --sort=-%cpu | head -6'\n</code></pre></p> </li> <li> <p>Cr\u00e9ez un alias pour voir uniquement vos processus : <pre><code>alias myproc='ps -u $USER'\n</code></pre></p> </li> </ol>"},{"location":"ressources/alias/#pour-aller-plus-loin","title":"Pour aller plus loin","text":""},{"location":"ressources/alias/#modeles-dalias-avances","title":"Mod\u00e8les d'alias avanc\u00e9s","text":"<pre><code># Alias avec param\u00e8tres via une fonction\npsig() {\n    ps -o pid,ppid,user,cmd -p $(pgrep -d, -f \"$1\")\n}\n</code></pre>"},{"location":"ressources/alias/#ressources-complementaires","title":"Ressources compl\u00e9mentaires","text":"<ul> <li>Documentation Debian : Shell Aliases</li> <li>Communaut\u00e9 : Awesome Bash Aliases</li> <li>Fiche gclasse sur les alias : Les alias sous Linux Debian</li> </ul>"},{"location":"ressources/alias/#conclusion","title":"Conclusion","text":"<p>Les alias sont des outils puissants pour simplifier votre travail quotidien avec les processus sous Linux. Prenez le temps de les personnaliser selon vos besoins et de maintenir votre collection d'alias.</p>"},{"location":"ressources/analogie-restaurant/","title":"Comprendre les processus Unix avec l'analogie du restaurant","text":"<p>Imaginez un grand restaurant en pleine activit\u00e9, avec ses serveurs qui s'affairent, son ma\u00eetre d'h\u00f4tel qui coordonne le service, et son chef de cuisine qui supervise toute l'organisation. Cette image famili\u00e8re nous servira de guide pour comprendre un des concepts les plus importants des syst\u00e8mes Unix : les processus et leur gestion.</p> <p>Comment tirer le meilleur parti de cette analogie</p> <p>Cette page est une r\u00e9f\u00e9rence que vous pouvez consulter \u00e0 tout moment. Au fil de vos exercices pratiques, revenez-y pour faire le lien entre ce que vous observez et les situations d\u00e9crites ici. Les concepts abstraits deviendront plus concrets gr\u00e2ce \u00e0 ces images mentales.</p>"},{"location":"ressources/analogie-restaurant/#la-structure-du-restaurant","title":"La structure du restaurant","text":""},{"location":"ressources/analogie-restaurant/#le-restaurant-notre-systeme-dexploitation","title":"Le restaurant : notre syst\u00e8me d'exploitation","text":"<p>Comme un syst\u00e8me d'exploitation g\u00e8re de nombreux processus, un restaurant g\u00e8re de multiples activit\u00e9s en parall\u00e8le. Dans cette analogie :</p> <p>Les correspondances cl\u00e9s</p> <p>\ud83d\udcbb Le restaurant correspond au syst\u00e8me d'exploitation \ud83d\udc68\u200d\ud83c\udf73 Le chef de cuisine repr\u00e9sente le kernel (noyau) \ud83d\udccb Le carnet des commandes est la table des processus</p>"},{"location":"ressources/analogie-restaurant/#les-acteurs-et-leurs-roles","title":"Les acteurs et leurs r\u00f4les","text":"<p>Le personnel du restaurant nous aide \u00e0 comprendre la hi\u00e9rarchie des processus :</p> <pre><code>graph TD\n    A[Chef de cuisine&lt;br/&gt;&lt;small&gt;Kernel&lt;/small&gt;] --&gt; B[Ma\u00eetre d'h\u00f4tel&lt;br/&gt;&lt;small&gt;Processus parent&lt;/small&gt;]\n    B --&gt; C[Serveur 1&lt;br/&gt;&lt;small&gt;Processus enfant&lt;/small&gt;]\n    B --&gt; D[Serveur 2&lt;br/&gt;&lt;small&gt;Processus enfant&lt;/small&gt;]\n    B --&gt; E[Serveur 3&lt;br/&gt;&lt;small&gt;Processus enfant&lt;/small&gt;]\n    style A fill:#f9d5e5,stroke:#333\n    style B fill:#eeeeee,stroke:#333\n    style C fill:#e3f2fd,stroke:#333\n    style D fill:#e3f2fd,stroke:#333\n    style E fill:#e3f2fd,stroke:#333</code></pre> <p>Chaque serveur, comme chaque processus, poss\u00e8de :</p> <ul> <li>Un num\u00e9ro unique d'identification (comme le PID)</li> <li>Un niveau d'exp\u00e9rience (comme la priorit\u00e9 d'ex\u00e9cution)</li> <li>Des t\u00e2ches assign\u00e9es (comme les instructions \u00e0 ex\u00e9cuter)</li> </ul>"},{"location":"ressources/analogie-restaurant/#les-etats-dun-serveur","title":"Les \u00e9tats d'un serveur","text":"<p>Un serveur, tout comme un processus, peut se trouver dans diff\u00e9rents \u00e9tats au cours de son service.</p>"},{"location":"ressources/analogie-restaurant/#en-activite-running","title":"En activit\u00e9 (Running)","text":"<p>Lorsqu'un serveur s'occupe activement de ses tables, il est comme un processus en cours d'ex\u00e9cution. Il :</p> <ul> <li>Prend les commandes</li> <li>Sert les plats</li> <li>Interagit avec les clients</li> </ul>"},{"location":"ressources/analogie-restaurant/#en-pause-stopped","title":"En pause (Stopped)","text":"<p>Quand un serveur prend sa pause cigarette, il est temporairement arr\u00eat\u00e9, comme un processus suspendu par Ctrl+Z. Il :</p> <ul> <li>N'est plus en salle</li> <li>Peut \u00eatre rappel\u00e9 si n\u00e9cessaire</li> <li>Conserve la m\u00e9moire de ses tables</li> </ul>"},{"location":"ressources/analogie-restaurant/#cas-particuliers","title":"Cas particuliers","text":"Le serveur zombieLe serveur orphelin <p>Un serveur qui a termin\u00e9 son service mais attend la validation de ses comptes par le ma\u00eetre d'h\u00f4tel est comme un processus zombie. Il ne travaille plus mais occupe encore une place dans le syst\u00e8me.</p> <p>Quand le ma\u00eetre d'h\u00f4tel part sans pr\u00e9venir, les serveurs deviennent orphelins. Le chef de salle (comme init) doit alors prendre le relais pour superviser ces serveurs.</p>"},{"location":"ressources/analogie-restaurant/#la-communication-par-signaux","title":"La communication par signaux","text":"<p>Dans un restaurant, les ordres et les communications sont essentiels, tout comme les signaux dans un syst\u00e8me Unix.</p>"},{"location":"ressources/analogie-restaurant/#les-ordres-quotidiens","title":"Les ordres quotidiens","text":"Signal restaurant \u00c9quivalent Unix Description \"Au service !\" SIGCONT Reprise du travail \"Pause !\" SIGTSTP Interruption temporaire \"Fin de service !\" SIGTERM Terminer proprement"},{"location":"ressources/analogie-restaurant/#les-urgences","title":"Les urgences","text":"Signal urgent \u00c9quivalent Unix Description \"URGENCE !\" SIGINT (Ctrl+C) Interruption imm\u00e9diate \"DEHORS !\" SIGKILL Arr\u00eat forc\u00e9 sans discussion"},{"location":"ressources/analogie-restaurant/#application-pratique","title":"Application pratique","text":"<p>Cette analogie prend tout son sens au fil des sc\u00e9narios d'apprentissage :</p> <p>Dans les sc\u00e9narios</p> <p>\ud83c\udf7d\ufe0f Sc\u00e9nario 2 : Gestion salle/bar comme foreground/background \ud83d\udc7b Sc\u00e9nario 3 : Les serveurs zombies \ud83e\udd14 Sc\u00e9nario 4 : Quand le ma\u00eetre d'h\u00f4tel dispara\u00eet \u2b50 Sc\u00e9nario 5 : L'exp\u00e9rience des serveurs</p> <p>Conseils d'utilisation</p> <ul> <li>Revenez consulter cette page apr\u00e8s chaque sc\u00e9nario</li> <li>Faites le lien avec vos observations pratiques</li> <li>Utilisez ces images pour expliquer les concepts \u00e0 vos pairs</li> </ul>"},{"location":"ressources/processus/","title":"Les processus sous Unix","text":"<p>Un syst\u00e8me d'exploitation Unix g\u00e8re de nombreux programmes en cours d'ex\u00e9cution simultan\u00e9ment. Pour comprendre comment cela fonctionne, nous devons d'abord comprendre ce qu'est un processus et comment il est g\u00e9r\u00e9 par le syst\u00e8me.</p>"},{"location":"ressources/processus/#introduction-aux-processus","title":"Introduction aux processus","text":""},{"location":"ressources/processus/#definition-et-role","title":"D\u00e9finition et r\u00f4le","text":"<p>Un processus (process) est un programme en cours d'ex\u00e9cution. Cette d\u00e9finition simple cache une r\u00e9alit\u00e9 plus complexe : un processus est en fait un environnement d'ex\u00e9cution complet qui comprend :</p> <ul> <li>Le code du programme \u00e0 ex\u00e9cuter</li> <li>Les donn\u00e9es en cours de traitement</li> <li>Les ressources syst\u00e8me allou\u00e9es</li> <li>Le contexte d'ex\u00e9cution (registres CPU, compteur ordinal, etc.)</li> </ul> <p>Programme vs Processus</p> <p>Un m\u00eame programme peut donner naissance \u00e0 plusieurs processus diff\u00e9rents : - Le programme Firefox est stock\u00e9 sur le disque dur - Chaque fois que vous lancez Firefox, un nouveau processus est cr\u00e9\u00e9 - Vous pouvez avoir plusieurs processus Firefox en m\u00eame temps - Chaque processus a son propre espace m\u00e9moire et ses propres ressources</p>"},{"location":"ressources/processus/#identification-des-processus","title":"Identification des processus","text":"<p>Chaque processus poss\u00e8de un identifiant unique appel\u00e9 PID (Process IDentifier). C'est un nombre entier attribu\u00e9 s\u00e9quentiellement par le syst\u00e8me :</p> <ul> <li>Le processus init (ou systemd sur les syst\u00e8mes modernes) a toujours le PID 1</li> <li>Les PID sont r\u00e9utilis\u00e9s quand un processus se termine</li> <li>Chaque processus conna\u00eet aussi le PID de son parent (PPID - Parent Process IDentifier)</li> </ul> <pre><code>graph TD\n    A[systemd&lt;br/&gt;PID: 1] --&gt; B[sshd&lt;br/&gt;PID: 423]\n    A --&gt; C[login&lt;br/&gt;PID: 567]\n    C --&gt; D[bash&lt;br/&gt;PID: 892]\n    D --&gt; E[firefox&lt;br/&gt;PID: 1234]\n    style A fill:#f9d5e5,stroke:#333</code></pre>"},{"location":"ressources/processus/#cycle-de-vie-dun-processus","title":"Cycle de vie d'un processus","text":""},{"location":"ressources/processus/#creation-dun-processus","title":"Cr\u00e9ation d'un processus","text":"<p>Sous Unix, les processus sont cr\u00e9\u00e9s par duplication (fork) :</p> <ol> <li>Un processus existant se clone lui-m\u00eame</li> <li>Le clone (processus enfant) a son propre PID</li> <li>L'enfant h\u00e9rite des ressources du parent</li> <li>L'enfant peut ensuite charger un nouveau programme (exec)</li> </ol>"},{"location":"ressources/processus/#etats-dun-processus","title":"\u00c9tats d'un processus","text":"<p>Un processus peut se trouver dans diff\u00e9rents \u00e9tats au cours de son existence :</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Ready: Cr\u00e9ation\n    Ready --&gt; Running: S\u00e9lection\n    Running --&gt; Ready: Fin quantum\n    Running --&gt; Blocked: Attente E/S\n    Blocked --&gt; Ready: E/S termin\u00e9e\n    Running --&gt; [*]: Terminaison</code></pre> <ul> <li>Pr\u00eat (Ready) : Attend son tour d'ex\u00e9cution</li> <li>En cours (Running) : S'ex\u00e9cute sur le processeur</li> <li>Bloqu\u00e9 (Blocked) : Attend une ressource ou un \u00e9v\u00e9nement</li> <li>Zombie (Zombie) : Termin\u00e9 mais non nettoy\u00e9</li> <li>Arr\u00eat\u00e9 (Stopped) : Suspendu temporairement</li> </ul> <p>L'importance de l'ordonnancement</p> <p>Le syst\u00e8me d'exploitation doit partager \u00e9quitablement le processeur entre tous les processus pr\u00eats. C'est le r\u00f4le de l'ordonnanceur (scheduler) qui d\u00e9cide quel processus ex\u00e9cuter et pendant combien de temps.</p>"},{"location":"ressources/processus/#hierarchie-des-processus","title":"Hi\u00e9rarchie des processus","text":""},{"location":"ressources/processus/#relations-parent-enfant","title":"Relations parent-enfant","text":"<p>Les processus Unix sont organis\u00e9s de mani\u00e8re hi\u00e9rarchique :</p> <ul> <li>Chaque processus (sauf init) a un parent</li> <li>Un processus peut avoir plusieurs enfants</li> <li>Quand un parent meurt, ses enfants sont adopt\u00e9s par init</li> <li>Les processus fr\u00e8res (siblings) partagent le m\u00eame parent</li> </ul>"},{"location":"ressources/processus/#propagation-des-signaux","title":"Propagation des signaux","text":"<p>La hi\u00e9rarchie influence la propagation des signaux :</p> <ul> <li>Certains signaux remontent vers le parent</li> <li>D'autres descendent vers les enfants</li> <li>Le parent est responsable de la terminaison de ses enfants</li> </ul>"},{"location":"ressources/processus/#environnement-dexecution","title":"Environnement d'ex\u00e9cution","text":""},{"location":"ressources/processus/#espace-memoire","title":"Espace m\u00e9moire","text":"<p>Chaque processus dispose de son propre espace m\u00e9moire virtuel :</p> <pre><code>graph TD\n    subgraph \"Espace m\u00e9moire virtuel\"\n        A[Text&lt;br/&gt;Code du programme] --&gt; B[Data&lt;br/&gt;Variables globales]\n        B --&gt; C[BSS&lt;br/&gt;Variables non initialis\u00e9es]\n        C --&gt; D[Heap&lt;br/&gt;M\u00e9moire dynamique]\n        D --&gt; E[Stack&lt;br/&gt;Variables locales]\n    end\n    style A fill:#e3f2fd,stroke:#333\n    style B fill:#e8f5e9,stroke:#333\n    style C fill:#fff3e0,stroke:#333\n    style D fill:#fce4ec,stroke:#333\n    style E fill:#f3e5f5,stroke:#333</code></pre>"},{"location":"ressources/processus/#descripteurs-de-fichiers","title":"Descripteurs de fichiers","text":"<p>Les processus interagissent avec l'ext\u00e9rieur via des descripteurs de fichiers :</p> <ul> <li>stdin (0) : Entr\u00e9e standard</li> <li>stdout (1) : Sortie standard</li> <li>stderr (2) : Sortie d'erreur</li> <li>Autres descripteurs pour les fichiers ouverts</li> </ul>"},{"location":"ressources/processus/#gestion-des-ressources","title":"Gestion des ressources","text":""},{"location":"ressources/processus/#priorites-dexecution","title":"Priorit\u00e9s d'ex\u00e9cution","text":"<p>Les processus peuvent avoir diff\u00e9rentes priorit\u00e9s :</p> <ul> <li>La priorit\u00e9 statique (nice value) est d\u00e9finie au lancement</li> <li>La priorit\u00e9 dynamique \u00e9volue selon l'utilisation du CPU</li> <li>Les processus syst\u00e8me ont g\u00e9n\u00e9ralement une priorit\u00e9 plus \u00e9lev\u00e9e</li> </ul>"},{"location":"ressources/processus/#limites-de-ressources","title":"Limites de ressources","text":"<p>Un processus est soumis \u00e0 diverses limites :</p> <ul> <li>Taille maximale de fichier</li> <li>Nombre de fichiers ouverts</li> <li>Quantit\u00e9 de m\u00e9moire utilisable</li> <li>Temps CPU disponible</li> </ul> <p>Visualiser les limites</p> <p>La commande <code>ulimit -a</code> permet de voir les limites actuelles du shell.</p>"},{"location":"ressources/processus/#outils-de-gestion-des-processus","title":"Outils de gestion des processus","text":"<p>Pour interagir avec les processus, Unix fournit plusieurs commandes essentielles :</p>"},{"location":"ressources/processus/#observation-des-processus","title":"Observation des processus","text":"<ul> <li><code>ps</code> : Liste des processus</li> <li><code>top</code> : Surveillance en temps r\u00e9el</li> <li><code>pstree</code> : Affichage hi\u00e9rarchique</li> </ul>"},{"location":"ressources/processus/#controle-des-processus","title":"Contr\u00f4le des processus","text":"<ul> <li><code>kill</code> : Envoi de signaux</li> <li><code>nice</code> / <code>renice</code> : Gestion des priorit\u00e9s</li> <li><code>bg</code> / <code>fg</code> : Gestion avant/arri\u00e8re plan</li> </ul> <p>Utilisation de kill</p> <p>Bien que son nom sugg\u00e8re la terminaison, <code>kill</code> sert en fait \u00e0 envoyer n'importe quel signal \u00e0 un processus. <code>kill -l</code> liste tous les signaux disponibles.</p>"},{"location":"ressources/processus/#pour-aller-plus-loin","title":"Pour aller plus loin","text":""},{"location":"ressources/processus/#lectures-recommandees","title":"Lectures recommand\u00e9es","text":"<ul> <li>\"Advanced Programming in the UNIX Environment\" de W. Richard Stevens</li> <li>\"Understanding the Linux Kernel\" de Daniel P. Bovet</li> <li>La page man de <code>proc(5)</code> pour les d\u00e9tails sur /proc</li> </ul>"},{"location":"ressources/processus/#concepts-avances-a-explorer","title":"Concepts avanc\u00e9s \u00e0 explorer","text":"<ul> <li>Les threads et la programmation multithread</li> <li>La communication inter-processus (IPC)</li> <li>Les conteneurs et la virtualisation</li> </ul>"},{"location":"ressources/signaux/","title":"Les signaux sous Unix","text":"<p>Les signaux sont un m\u00e9canisme fondamental de communication entre processus sous Unix. Imaginez-les comme un syst\u00e8me d'alerte ou de notification qui permet d'informer les processus d'\u00e9v\u00e9nements importants ou de leur demander d'effectuer certaines actions.</p>"},{"location":"ressources/signaux/#comprendre-les-signaux","title":"Comprendre les signaux","text":""},{"location":"ressources/signaux/#quest-ce-quun-signal","title":"Qu'est-ce qu'un signal ?","text":"<p>Un signal (signal) est une forme d'interruption logicielle envoy\u00e9e \u00e0 un processus pour lui notifier un \u00e9v\u00e9nement. C'est un peu comme si vous tapiez sur l'\u00e9paule de quelqu'un pour attirer son attention : le processus interrompt son activit\u00e9 normale pour \"regarder\" ce qu'on lui veut.</p> <p>Les signaux au quotidien</p> <p>Vous utilisez d\u00e9j\u00e0 les signaux sans le savoir ! Quand vous appuyez sur Ctrl+C dans un terminal, vous envoyez un signal SIGINT au processus en cours. C'est une fa\u00e7on polie de lui dire \"S'il te pla\u00eet, arr\u00eate-toi\".</p>"},{"location":"ressources/signaux/#caracteristiques-des-signaux","title":"Caract\u00e9ristiques des signaux","text":"<p>Les signaux ont plusieurs propri\u00e9t\u00e9s importantes :</p> <ol> <li>Asynchrones : Ils peuvent arriver \u00e0 n'importe quel moment</li> <li>Limit\u00e9s : Ils ne transportent pas de donn\u00e9es, juste un num\u00e9ro</li> <li>Non empil\u00e9s : Un m\u00eame signal r\u00e9p\u00e9t\u00e9 pendant le traitement du premier est ignor\u00e9</li> <li>Configurables : Un processus peut choisir comment r\u00e9agir \u00e0 la plupart des signaux</li> </ol>"},{"location":"ressources/signaux/#les-signaux-standard","title":"Les signaux standard","text":""},{"location":"ressources/signaux/#les-signaux-les-plus-courants","title":"Les signaux les plus courants","text":"<pre><code>graph TD\n    A[Signaux courants] --&gt; B[Interruption&lt;br/&gt;SIGINT - 2]\n    A --&gt; C[Terminaison&lt;br/&gt;SIGTERM - 15]\n    A --&gt; D[Kill&lt;br/&gt;SIGKILL - 9]\n    A --&gt; E[Suspension&lt;br/&gt;SIGTSTP - 20]\n    A --&gt; F[Continuation&lt;br/&gt;SIGCONT - 18]\n\n    style A fill:#f9d5e5,stroke:#333\n    style B fill:#e3f2fd,stroke:#333\n    style C fill:#e3f2fd,stroke:#333\n    style D fill:#fce4ec,stroke:#333\n    style E fill:#e3f2fd,stroke:#333\n    style F fill:#e3f2fd,stroke:#333</code></pre> Signal Num\u00e9ro Description Raccourci SIGINT 2 Interruption interactive Ctrl+C SIGTERM 15 Terminaison propre - SIGKILL 9 Terminaison forc\u00e9e - SIGTSTP 20 Suspension Ctrl+Z SIGCONT 18 Reprise d'ex\u00e9cution -"},{"location":"ressources/signaux/#les-signaux-du-clavier","title":"Les signaux du clavier","text":"<p>Le terminal traduit certaines combinaisons de touches en signaux :</p> <p>Voir les raccourcis configur\u00e9s</p> <p>La commande <code>stty -a</code> affiche tous les raccourcis clavier configur\u00e9s dans votre terminal. <pre><code>stty -a\n</code></pre></p>"},{"location":"ressources/signaux/#comportements-speciaux","title":"Comportements sp\u00e9ciaux","text":"<p>Certains signaux ont des particularit\u00e9s importantes :</p> SIGKILL et SIGSTOPSIGCHLDSIGUSR1 et SIGUSR2 <p>Ces signaux ne peuvent pas \u00eatre ignor\u00e9s ou intercept\u00e9s par les processus. Ils sont l'\u00e9quivalent d'un arr\u00eat d'urgence.</p> <p>Envoy\u00e9 au parent quand un processus enfant se termine. Crucial pour \u00e9viter les processus zombies.</p> <p>Signaux laiss\u00e9s \u00e0 la disposition des programmeurs pour un usage personnalis\u00e9.</p>"},{"location":"ressources/signaux/#gestion-des-signaux","title":"Gestion des signaux","text":""},{"location":"ressources/signaux/#comment-envoyer-un-signal","title":"Comment envoyer un signal","text":"<p>La commande <code>kill</code> permet d'envoyer n'importe quel signal \u00e0 un processus :</p> <pre><code># Syntaxe : kill -signal pid\nkill -TERM 1234    # Envoie SIGTERM au processus 1234\nkill -9 1234       # Envoie SIGKILL (force l'arr\u00eat)\n</code></pre> <p>Le nom trompeur de kill</p> <p>Malgr\u00e9 son nom, <code>kill</code> n'est pas uniquement destin\u00e9 \u00e0 terminer des processus. C'est un outil g\u00e9n\u00e9ral d'envoi de signaux.</p>"},{"location":"ressources/signaux/#reception-des-signaux","title":"R\u00e9ception des signaux","text":"<p>Quand un processus re\u00e7oit un signal, plusieurs sc\u00e9narios sont possibles :</p> <ol> <li>Action par d\u00e9faut : Comportement standard du syst\u00e8me</li> <li>Gestionnaire personnalis\u00e9 : Le processus traite le signal \u00e0 sa fa\u00e7on</li> <li>Ignorance : Le processus peut ignorer certains signaux</li> <li>Blocage : Le processus peut temporairement bloquer des signaux</li> </ol> <pre><code>flowchart LR\n    A[Signal re\u00e7u] --&gt; B{Bloqu\u00e9 ?}\n    B --&gt;|Oui| C[Mise en attente]\n    B --&gt;|Non| D{Handler ?}\n    D --&gt;|Oui| E[Gestionnaire&lt;br/&gt;personnalis\u00e9]\n    D --&gt;|Non| F[Action par&lt;br/&gt;d\u00e9faut]\n\n    style A fill:#f9d5e5,stroke:#333\n    style B fill:#e3f2fd,stroke:#333\n    style C fill:#fce4ec,stroke:#333\n    style D fill:#e3f2fd,stroke:#333\n    style E fill:#e8f5e9,stroke:#333\n    style F fill:#fff3e0,stroke:#333</code></pre>"},{"location":"ressources/signaux/#utilisation-pratique-des-signaux","title":"Utilisation pratique des signaux","text":""},{"location":"ressources/signaux/#cas-dusage-courants","title":"Cas d'usage courants","text":"<p>Les signaux sont utilis\u00e9s dans de nombreuses situations :</p> <ol> <li>Contr\u00f4le de processus</li> <li>Arr\u00eat propre (SIGTERM)</li> <li>Arr\u00eat forc\u00e9 (SIGKILL)</li> <li> <p>Suspension/reprise (SIGTSTP/SIGCONT)</p> </li> <li> <p>Gestion des d\u00e9mons</p> </li> <li>Rechargement de configuration (SIGHUP)</li> <li> <p>Rotation des logs (SIGUSR1)</p> </li> <li> <p>D\u00e9bogage</p> </li> <li>Interruption pour inspection (SIGSTOP)</li> <li>Reprise d'ex\u00e9cution (SIGCONT)</li> </ol>"},{"location":"ressources/signaux/#bonnes-pratiques","title":"Bonnes pratiques","text":"<p>Pour une gestion efficace des signaux :</p> <ol> <li>Pr\u00e9f\u00e9rez SIGTERM \u00e0 SIGKILL pour terminer un processus</li> <li>G\u00e9rez proprement SIGCHLD pour \u00e9viter les zombies</li> <li>Documentez l'utilisation de SIGUSR1/SIGUSR2</li> <li>Pensez \u00e0 sauvegarder les donn\u00e9es avant de terminer</li> </ol> <p>Diagnostic avec strace</p> <p>La commande <code>strace</code> permet de voir les signaux re\u00e7us par un processus : <pre><code>strace -e signal ./monprogramme\n</code></pre></p>"},{"location":"ressources/signaux/#dans-nos-exercices-pratiques","title":"Dans nos exercices pratiques","text":"<p>Au cours des diff\u00e9rents sc\u00e9narios, vous rencontrerez plusieurs situations impliquant des signaux :</p> <p>Utilisation des signaux</p> <p>\ud83c\udfae Sc\u00e9nario 2 : Utilisation de SIGTSTP et SIGCONT \ud83d\udc7b Sc\u00e9nario 3 : Gestion de SIGCHLD \ud83e\udd16 Programme proclab : Utilisation de SIGUSR1/SIGUSR2 pour l'aide</p>"},{"location":"ressources/signaux/#pour-aller-plus-loin","title":"Pour aller plus loin","text":""},{"location":"ressources/signaux/#documentation-systeme","title":"Documentation syst\u00e8me","text":"<ul> <li><code>man 7 signal</code> : Liste compl\u00e8te des signaux</li> <li><code>man 2 signal</code> : Programmation des gestionnaires</li> <li><code>man 2 sigaction</code> : Interface moderne de gestion</li> </ul>"},{"location":"ressources/signaux/#concepts-avances","title":"Concepts avanc\u00e9s","text":"<ul> <li>Les masques de signaux</li> <li>Les ensembles de signaux (sigset)</li> <li>Les signaux temps r\u00e9el</li> <li>La gestion des signaux dans les threads</li> </ul>"}]}